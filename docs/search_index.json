[
["index.html", "Preface", " Preface docendo discimus (by teaching we learn) —Seneca the Younger (c. 4 BC – 65 AD) This is a personal repository for digesting concepts and practicing critical storytelling related to analyzing data, mainly using the R Project for Statistical Computing. "],
["introduction.html", "Introduction", " Introduction I intend to follow a project-oriented workflow for organizing this information: Programming Import Tidy Transform Visualise Statistics Communicate "],
["licensing.html", "Licensing", " Licensing I am publishing this book with no license, which means: When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. "],
["about-the-author.html", "About the Author", " About the Author I am the lead Data Analytics Consultant in HR for the University of Missouri System. I earned my BFA summa cum laude from the University of Missouri in 2009, with a minor in Art History; and have been employed by the University since 2009. "],
["programming.html", "1 Programming", " 1 Programming "],
["advanced-r.html", "1.1 Advanced R", " 1.1 Advanced R Advanced R 2nd ed. Hadley Wickham Selected Chapters Names and Values Vectors Subsetting Control Flow Functions Functionals 1.1.1 Names and Values 1.1.1.1 Binding In R, names are assigned a value (e.g. a vector doesn’t have a name, rather, a name(s) points to a vector). The actual address of an object is exposed by lobstr::obj_addr(). x &lt;- 1:10 obj_addr(x) ## [1] &quot;0x1517f8b0&quot; # notice x and y are pointers to the same object y &lt;- x obj_addr(y) ## [1] &quot;0x1517f8b0&quot; # this applies to function arguments in their environment as well fn &lt;- function(z){ z } # fn() returns the argument z at the same address obj_addr(fn(x)) ## [1] &quot;0x1517f8b0&quot; 1.1.1.2 Syntactic Names Names in R can be letters, numbers, . or _; but cannot start with a number or _ or contain ?Reserved words. # assigning a vector a name startign with `_` throws an error _x &lt;- 1:10 ## Error: &lt;text&gt;:2:1: unexpected input ## 1: # assigning a vector a name startign with `_` throws an error ## 2: _ ## ^ 1.1.1.3 Copy-on-Modify R objects are generally immutable. A new copy is made when you modify an object. There are two Modify-in-Place exceptions. # create vector x x &lt;- 1:10 obj_addr(x) ## [1] &quot;0x180fe9d8&quot; # modify first value in x x[[1]] &lt;- 0 # note x now points to a new object obj_addr(x) ## [1] &quot;0x1806d148&quot; 1.1.1.3.1 Trace Copying of Objects base::tracemem() will mark an object and print a message whenever it is copied. This is a major cause of hard-to-predict memory usage. # tell R to trace copies of object reference `x` tracemem(x = x) # modify the first element in vector `x` # R prints a tracemem message to show the object is copied to a new address x[[1]] &lt;- 2 #&gt; tracemem[0x000002379ca5a190 -&gt; 0x000002379cd8dbb0]: # tell R to stop tracing this object base::untracemem(x = x) 1.1.1.3.2 List Objects Just like variables, each element of a list also points to a value. Copy-on-modify and modify-in-place applies here as well. R creates a shallow copy of the list. Meaning the list object and its bindings are copied; however, the underlying values are not. In a deep copy, like prior to R 3.1.0, the underlying values are also copied. # create a list named `l` l &lt;- list(1:10, TRUE, c(&#39;Apple&#39;,&#39;Broccoli&#39;,&#39;Chowder&#39;)) # show the address of the third list element obj_addr(l[[3]]) ## [1] &quot;0x18641c28&quot; # modify the third list element l[[3]] &lt;- c(&#39;Appricot&#39;,&#39;Basmati Rice&#39;,&#39;Cheese&#39;) # the third list element&#39;s address is changed obj_addr(l[[3]]) ## [1] &quot;0x186db4c0&quot; Use lobstr::ref() to see common values between lists: # create a list object listA &lt;- list(1,2,3) # create a new pointer to the same list object listB &lt;- listA # modify the third list element of listB, creating a shallow copy of the list object listB[[3]] &lt;- 4 # ref() lists the address of each list element. Notice two values are still shared # between `listA` and `listB`. ref(listA, listB) ## o [1:0x18ad0ff0] &lt;list&gt; ## +-[2:0x189423a8] &lt;dbl&gt; ## +-[3:0x18942370] &lt;dbl&gt; ## \\-[4:0x18942338] &lt;dbl&gt; ## ## o [5:0x18b87d90] &lt;list&gt; ## +-[2:0x189423a8] ## +-[3:0x18942370] ## \\-[6:0x18942220] &lt;dbl&gt; 1.1.1.3.3 Data Frames A data frame is simply a list where each element is a vector of the same length. # create a data frame with three columns df &lt;- data.frame(col1 = TRUE, col2 = 1:10, col3 = rep(x = c(&#39;On&#39;,&#39;Off&#39;), length.out = 10)) # show the address of the data frame and each element (i.e. column) ref(df) ## o [1:0x195b9330] &lt;df[,3]&gt; ## +-col1 = [2:0x19580628] &lt;lgl&gt; ## +-col2 = [3:0x195aaaf0] &lt;int&gt; ## \\-col3 = [4:0x19580778] &lt;fct&gt; When a column is modified only one element is copied: # modify a column and note the addresses of the unchanged columns remain the same # because they point to the same objects as before df$col1 &lt;- FALSE; ref(df) ## o [1:0x198fd0d8] &lt;df[,3]&gt; ## +-col1 = [2:0x198b3110] &lt;lgl&gt; ## +-col2 = [3:0x195aaaf0] &lt;int&gt; ## \\-col3 = [4:0x19580778] &lt;fct&gt; This has important consequences for memory when you update rows of data where each element gets copied: # modify the first row of the data frame df[1,] &lt;- c(TRUE, 0, &#39;Off&#39;) # *all* elements are copied to new addresses ref(df) ## o [1:0x15fded80] &lt;df[,3]&gt; ## +-col1 = [2:0x160c22b0] &lt;chr&gt; ## +-col2 = [3:0x158b5f90] &lt;chr&gt; ## \\-col3 = [4:0x160189b8] &lt;fct&gt; 1.1.1.3.4 Character Vectors R uses a global string pool to store unique character objects so they are not duplicated unnecessarily. Use the character argument to show their address in the global string pool with lobstr::ref(): # create a character vector chr &lt;- c(&#39;Quarter&#39;, &#39;Dime&#39;, &#39;Nickle&#39;, &#39;Penny&#39;, &#39;Penny&#39;) # show addresses in the global string pool. Notice the shared value for &#39;Penny&#39; ref(chr, character = TRUE) ## o [1:0x17e3a7f8] &lt;chr&gt; ## +-[2:0x15cd8930] &lt;string: &quot;Quarter&quot;&gt; ## +-[3:0x15cd88c0] &lt;string: &quot;Dime&quot;&gt; ## +-[4:0x15cd8818] &lt;string: &quot;Nickle&quot;&gt; ## +-[5:0x15cd87a8] &lt;string: &quot;Penny&quot;&gt; ## \\-[5:0x15cd87a8] 1.1.1.4 Object Size lobstr::obj_size() shows the amount of memory an object takes, while obj_sizes() breaks down multiple objects into their individual contribution to total memory. Due to binding names, global string pools, and ALTREP (alternate representation where some vectors are stored in a compact manor; e.g. 1:1000 only stores the first and last numbers, not 1,000 numbers) the size of objects may surprise you. # create a length one chracter vector and a length 100 character vector x &lt;- &#39;Charlie&#39; y &lt;- rep(x = &#39;Charlie&#39;, times = 100) # y is only ~8x the size of x, not 100x obj_size(x); obj_size(y) ## 112 B ## 904 B z &lt;- 1:10 # create a list with one element `z` list1 &lt;- list(z) # create a list with three elements, all `z` list2 &lt;- list(z, z, z) # list2 only contributes an extra 80 Bytes to the total memory between the two obj_sizes(list1, list2) ## * 736 B ## * 80 B 1.1.1.5 Modify-in-Place There are two places where R will optimize memory by modfiying an object “in place” (i.e. does not make a copy). objects with a single binding &gt; hats &lt;- c(&#39;red&#39;,&#39;brown&#39;,&#39;blue&#39;) &gt; obj_addr(hats) [1] &quot;0x1d51fe614d8&quot; &gt; &gt; hats[[1]] &lt;- &#39;orange&#39; &gt; obj_addr(hats) [1] &quot;0x1d51fe614d8&quot; # note this is output from the R Console. RStudio runs everything within an Environment # which breaks modify-in-place behavior This is one reason why looping in R is inefficient, the user is unwittingly copying objects many times over: # create a dataframe df &lt;- data.frame(col1 = c(1:3)) # trace copies of this dataframe tracemem(df) ## [1] &quot;&lt;00000000187C6918&gt;&quot; # use a for loop to increment the dataframe values # R copies the object 12 times!!! for (i in 1:3){ df[[1]][i] &lt;- df[[1]][i] + 1 } ## tracemem[0x00000000187c6918 -&gt; 0x0000000018a09a00]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a09a00 -&gt; 0x0000000018a09840]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a09840 -&gt; 0x0000000018a19d10]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a19d10 -&gt; 0x0000000018a19b88]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a19b88 -&gt; 0x0000000018a19a00]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a19a00 -&gt; 0x0000000018a198b0]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a198b0 -&gt; 0x0000000018a197d0]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a197d0 -&gt; 0x0000000018a19648]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a19648 -&gt; 0x0000000018a194c0]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a194c0 -&gt; 0x0000000018a19370]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a19370 -&gt; 0x0000000018a19290]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000018a19290 -&gt; 0x0000000018a19108]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local # turn of object memory trace untracemem(df) Environments Environments are always modified in place and all objects within the environment keep the same reference. 1.1.1.6 Unbinding and Garbage Collector (GC) The (GC) garbage collector deletes objects that are no longer used and requests more memory from the operating system as needed to create objects. For example: # create three objects all bound to `x` x &lt;- 1:10 x &lt;- c(&#39;one&#39;,&#39;two&#39;,&#39;three&#39;) x &lt;- TRUE # removing `x` causes GC to delete the three objects b/c they have no other bindings remove(x) You can call GC yourself with base::gc(), but the user should not ever have the need. 1.1.2 Vectors R has two types of vectors: atomic vectors and list vectors. Atomic vectors have values all of the same type, while lists can have values of different types. NULL is not a vector, but is often used in R to represent a zero length vector. For practical purposes you can consider it a vector. Vectors can have attributes; the most important are dimension and class. dimension: turns a vector into matrices and arrays class: critical for S3 objects like factors, dates &amp; date-time, data frames, and tibbles 1.1.2.1 Atomic Vectors 1.1.2.1.1 Types There are four primary types of atomic vectors, and their scalars (i.e. individual value) can be instantiated as: Logical: TRUE/T;FALSE/F Double: decimal 2.345, scientific 2e10, hexadecimal 3425h, infinite Inf/-Inf, Not a Number NaN Integer: a non-fractional double followed by L (e.g. 7L, 2e7L, 3425hL ) Character: strings surrounded by single/double quotes; 'Cats' or \"Dogs\" Doubles and Integers belong to meta-type numeric. is.numeric() tests if a vector can be interpreted as a number: is.numeric(2.2) = TRUE = is.numeric(2L) = TRUE 1.1.2.1.2 Combine scalars Scalars can be combined to make longer vectors using c(): c(1,2,3) ## [1] 1 2 3 c(T,T,F) ## [1] TRUE TRUE FALSE R will flatten atomic vectors when combined with other atomic vectors: c(1,c(2,c(2.1,2.2,2.3)),4) ## [1] 1.0 2.0 2.1 2.2 2.3 4.0 typeof() and length() will return the type and length of an atomic vector: x &lt;- TRUE; y &lt;- c(1L, 2L, 3L, 4L) typeof(x); length(x) ## [1] &quot;logical&quot; ## [1] 1 typeof(y); length(y) ## [1] &quot;integer&quot; ## [1] 4 typeof(NULL); length(NULL) ## [1] &quot;NULL&quot; ## [1] 0 1.1.2.1.3 Missing values Missing values are represented by NA (Not Applicable). There are logical (NA), integer (NA_integer_), double (NA_real_), and character (NA_character_) types but R will parse the appropriate NA needed. Many logistical tests in R containing NA will return NA: # not false returns true; not NA returns NA !FALSE; !NA ## [1] TRUE ## [1] NA For this reason, finding missing values in a vector is not obvious: x &lt;- c(0,NA,NA,3,4) # a logistical test for NA returns all NA x==NA ## [1] NA NA NA NA NA Instead, use is.na() to test for missing values: is.na(x) ## [1] FALSE TRUE TRUE FALSE FALSE The exception is when all possible values would not change the result: # this logical statement is true regardless of all possible NA values NA | TRUE ## [1] TRUE 1.1.2.1.4 Testing and coercing vectors There are many is.*() pattern functions in R to test vector type. is.logical(), is.integer(), is.double(), and is.character() all test for the four primary atomic vector types: is.logical(x = c(T,T,F,F)) ## [1] TRUE is.integer(x = c(2.2, 3.0)) ## [1] FALSE However, some is.*() pattern functions behave unexpectedly. is.numeric(), for example, returns false for factors, Date, POSIXt and difftime because they have their own methods for detection; even though they are numbers and arithmetic generally makes sense. So be sure to read the documentation carefully (?is.numeric()). coercing types It is possible to coerce vectors to a new type, or two combine two types of vectors into one. The types will be coerced in this order: character &gt; double &gt; integer &gt; logical Use as.*() functions to specifically coerce types. R can also implicitly coerce types when needed. R will give a warning message if it fails or NAs are introduced. # combining a double and a character returns a character vector str(c(1,&quot;2&quot;)) ## chr [1:2] &quot;1&quot; &quot;2&quot; # implicitly return the sum of a logical as integer str(sum(c(T,T,F))) ## int 2 # explicitly coerce doubles to characters str(as.character(c(2e1, 200))) ## chr [1:2] &quot;20&quot; &quot;200&quot; 1.1.2.2 Attributes Other data-structures in R are built on top of these atomic vectors using attributes. For example, the dimension attribute transforms vectors into matrices and arrays. 1.1.2.2.1 Getting and setting attributes Attributes are like meta-data you assign in name-value pairs: attr() to retrieve and set single attributes attributes() to retrieve multiple attributes structure() to set multiple attributes fruit &lt;- 1:10 # create fruit attributes type and days old attr(x = fruit, which = &#39;type&#39;) &lt;- c(&#39;orange&#39;,&#39;apple&#39;,&#39;pear&#39;) attr(fruit,&#39;type&#39;) ## [1] &quot;orange&quot; &quot;apple&quot; &quot;pear&quot; attr(x = fruit, which = &#39;days old&#39;) &lt;- 2 str(attributes(x = fruit)) ## List of 2 ## $ type : chr [1:3] &quot;orange&quot; &quot;apple&quot; &quot;pear&quot; ## $ days old: num 2 # simultaneously create object and attributes fruit &lt;- structure( 1:10, type = c(&#39;orange&#39;,&#39;apple&#39;,&#39;pear&#39;), &#39;days old&#39; = 2 ) str(attributes(fruit)) ## List of 2 ## $ type : chr [1:3] &quot;orange&quot; &quot;apple&quot; &quot;pear&quot; ## $ days old: num 2 1.1.2.2.2 Names names is a special and important attribute in R. Although it is not enforced, names should be unique and complete. They can be set several ways: # on creation x &lt;- c(a=1,b=2,c=3) attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # assigning a vector of names x &lt;- 1:3 names(x) &lt;- letters[1:3] attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # inline with setNames() x &lt;- setNames(1:3, letters[1:3]) attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # with attr() attr(x, which = &#39;names&#39;) &lt;- letters[1:3] attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 1.1.2.2.3 Dimensions The dim attribute transforms NULL dimensional vectors into 2d matrices and multi-dimensional arrays, and can be set by dim(), matrix(), and array(): x &lt;- 1:6 dim(x) &lt;- c(2,3) x ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix(data = 1:6, nrow = 1, ncol = 6) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 array(data = 1:6, dim = c(2,3)) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # non-idiomatic attr(x, &#39;dim&#39;) &lt;- c(3,2) x ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Vector functions usually have matrix or array counterparts: # vector, matrix, and array bindings v &lt;- structure(.Data = 1:9, names = letters[1:9]) m &lt;- matrix(data = 1:9, nrow = 3, ncol = 3, dimnames = list(letters[1:3], letters[1:3])) a &lt;- array(data = 1:9, dim = c(3,3), dimnames = list(letters[1:3], letters[1:3])) # Names names(v) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; rownames(m); colnames(m) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; dimnames(a) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # Lengths length(v) ## [1] 9 nrow(m);ncol(m) ## [1] 3 ## [1] 3 dim(a) ## [1] 3 3 # Combine c(v, c(j=10)) ## a b c d e f g h i j ## 1 2 3 4 5 6 7 8 9 10 rbind(m, 10:12);cbind(m, 10:12) ## a b c ## a 1 4 7 ## b 2 5 8 ## c 3 6 9 ## 10 11 12 ## a b c ## a 1 4 7 10 ## b 2 5 8 11 ## c 3 6 9 12 abind::abind(a, 10:12, along=1); abind::abind(a, 10:12, along=2) ## a b c ## a 1 4 7 ## b 2 5 8 ## c 3 6 9 ## 10 11 12 ## a b c ## a 1 4 7 10 ## b 2 5 8 11 ## c 3 6 9 12 # Transpose t(m) ## a b c ## a 1 2 3 ## b 4 5 6 ## c 7 8 9 aperm(a) ## a b c ## a 1 2 3 ## b 4 5 6 ## c 7 8 9 # Type test is.vector(v, mode=&#39;any&#39;) ## [1] TRUE is.matrix(m) ## [1] TRUE is.array(a) ## [1] TRUE Vectors may have different dimensions. They may print similar but will behave differently. Pay attention to [] syntax: # 1d vector str(1:10) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 # column vector str(matrix(1:10, ncol = 1)) ## int [1:10, 1] 1 2 3 4 5 6 7 8 9 10 # row vector str(matrix(1:10, nrow = 1)) ## int [1, 1:10] 1 2 3 4 5 6 7 8 9 10 # 1d &quot;array&quot; vector str(array(1:10, 10)) ## int [1:10(1d)] 1 2 3 4 5 6 7 8 9 10 1.1.2.3 S3 Atomic Vectors The attribute class is what makes an object part of the S3 object system in R, and changes how generic functions behave compared to regular vectors. S3 objects are built on top of atomic vectors. 1.1.2.3.1 Factors Factors are a ubiquitous S3 object in base R. They handle categorical variables where the vector must contain only known values. Factors are built on atomic vectors of type integer, and only have two attributes: class “factor” and levels, which defines the set, and sometimes order, of possible values. Use factor() create a factor: x: a vector coercible to character levels: a unique vector of expected values in x; which can contain values not found in x or, conversely, exclude values found in x labels: a vector of name aliases for levels (in the same order as levels) or scalar # create a factor from a vector of state abbreviations # tell R to expect values MO, NY, AK, HI and their aliases are Missouri, New York, Alaska, # &amp; Hawaii states &lt;- factor(x = c(&#39;MO&#39;,&#39;NY&#39;,&#39;AK&#39;,&#39;MO&#39;,&#39;AK&#39;,&#39;IL&#39;), levels = c(&#39;MO&#39;,&#39;NY&#39;,&#39;AK&#39;,&#39;HI&#39;), labels = c(&#39;Missouri&#39;,&#39;New York&#39;,&#39;Alaska&#39;,&#39;Hawaii&#39;)) # factor() converts the vector to integer values under-the-hood. These are rarely visible # but can be exposed using c() (or unclass() but then you no longer have a factor). The # integer refers to the sequence of levels given, starting with &#39;MO&#39; in this case. str(c(states)) ## int [1:6] 1 2 3 1 3 NA # usually factors print their levels attribute states ## [1] Missouri New York Alaska Missouri Alaska &lt;NA&gt; ## Levels: Missouri New York Alaska Hawaii # notice it did not print the levels given in factor(), but rather the label aliases # were given to attribute `levels`. If no labels argument is given it defaults to same # as levels. attributes(states) ## $levels ## [1] &quot;Missouri&quot; &quot;New York&quot; &quot;Alaska&quot; &quot;Hawaii&quot; ## ## $class ## [1] &quot;factor&quot; # if no levels argument was given, factor() would have defaulted to the unique set of values # in x in ascending order. Note this would include Illinois (which we originally excluded and # values in states became `NA`), and would have excluded Hawaii (which we may have wanted # even though it is not in the current vector x). sort(unique(as.character(c(&#39;MO&#39;,&#39;NY&#39;,&#39;AK&#39;,&#39;MO&#39;,&#39;AK&#39;,&#39;IL&#39;)))) ## [1] &quot;AK&quot; &quot;IL&quot; &quot;MO&quot; &quot;NY&quot; # notice tabulated results appear in level order and include counts even for values not # present in states table(states) ## states ## Missouri New York Alaska Hawaii ## 2 1 2 0 # many base R functions convert character vectors to factor by default. This may not be # desirable as the vector may not contain the complete set of values, or infer their # correct order. class(data.frame(x=c(&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;))[[1]]) ## [1] &quot;factor&quot; # use arguement stringsAsFactor to inhibit default factor creation class(data.frame(x=c(&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;), stringsAsFactors = FALSE)[[1]]) ## [1] &quot;character&quot; Some categorical variables have order. Methods and modeling functions usually treat ordered and unordered factors very differently. Use ordered() to create an object of class “ordered factor”, where the order in levels implies the order between factor levels. priority &lt;- ordered(x = c(&#39;low&#39;,&#39;medium&#39;,&#39;high&#39;), levels = c(&#39;low&#39;,&#39;medium&#39;,&#39;high&#39;)) str(priority) ## Ord.factor w/ 3 levels &quot;low&quot;&lt;&quot;medium&quot;&lt;..: 1 2 3 Finally, some functions coerce factors into strings (e.g. grepl()) while others (e.g. c()) return the integer substrate. If you want string-like behavior, best to coerce as.character() before performing string operations. 1.1.2.3.2 Dates Date vectors are S3 objects built on type double, and have only attribute: class “Date”. They represent days from the UNIX Epoch, 01-Jan-1970; and take into account leap-days, but not leap-seconds. # today&#39;s date today &lt;- Sys.Date() typeof(today) ## [1] &quot;double&quot; class(today) ## [1] &quot;Date&quot; # unclass the Date object to see the underlying double unclass(today) ## [1] 18399 1.1.2.3.3 Date-times S3 Date-times come in two flavors: POSIX1ct (calendar time) &amp; POSIXlt (local time). POSIXct is build on type double whereas POSIXlt is type list, which we’ll discuss later. POSIXct represents the number of seconds since the UNIX Epoch, 01-JAN-1970, and has the attributes class &amp; tzone. Pass the tz argument a tz database time zone to change attribute tzone from the default local time. This does not change the underlying double, only how it prints. ct &lt;- as.POSIXct(x = &quot;2020-04-28 05:00:00&quot;, tz=&#39;UTC&#39;) # the calendar time object ct ## [1] &quot;2020-04-28 05:00:00 UTC&quot; # built on doubles typeof(ct) ## [1] &quot;double&quot; # has attributes class and tzone attributes(ct) ## $class ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; ## ## $tzone ## [1] &quot;UTC&quot; # change tzone attribute to EDT, CDT, JST; notice midnight does not print a time attr(ct, which = &#39;tzone&#39;) &lt;- &#39;America/New_York&#39;; ct; ## [1] &quot;2020-04-28 01:00:00 EDT&quot; attr(ct, which = &#39;tzone&#39;) &lt;- &#39;America/Chicago&#39;; ct ## [1] &quot;2020-04-28 CDT&quot; attr(ct, which = &#39;tzone&#39;) &lt;- &#39;Asia/Tokyo&#39;; ct ## [1] &quot;2020-04-28 14:00:00 JST&quot; # the underlying double type atomic vector unclass(ct)[1] ## [1] 1588050000 1.1.2.3.4 Difftimes Difftimes are doubles which represent a duration of time (interpreted by attribute units) between two dates/datetimes. units includes “secs”, “mins”, “hours”, “days”, and “weeks” and are not sensitive to daylight savings time. Limited math methods and arithmetic is available for difftime. See ?difftime. # create difftime directly day &lt;- as.difftime(1, units = &#39;days&#39;) day ## Time difference of 1 days # create difftime by arithmetic day_alt &lt;- as.Date(&quot;2020-04-28&quot;) - as.Date(&quot;2020-04-27&quot;) day_alt ## Time difference of 1 days typeof(day) ## [1] &quot;double&quot; class(day) ## [1] &quot;difftime&quot; attributes(day) ## $class ## [1] &quot;difftime&quot; ## ## $units ## [1] &quot;days&quot; # retrive/set units directly using units() units(day) &lt;- &#39;hours&#39; # day is now a 24 hour timediff day ## Time difference of 24 hours # add difftime to Date to return Date as.Date(&quot;2020-04-28&quot;) + (2*day) ## [1] &quot;2020-04-30&quot; # add difftime to difftime to return difftime as.difftime(.5, units=&#39;mins&#39;) + as.POSIXct(&#39;2020-03-02 00:00:00&#39;) ## [1] &quot;2020-03-02 00:00:30 CST&quot; # transform difftime by numeric to return difftime day/2 ## Time difference of 12 hours # transform difftime by difftime to return difftime day+day ## Time difference of 48 hours # math methods are to describe difftime vectors mean(c(as.Date(&quot;2020-04-28&quot;) - as.Date(&quot;2020-04-27&quot;), as.Date(&quot;2020-04-28&quot;) - as.Date(&quot;2020-04-26&quot;))) ## Time difference of 1.5 days # round difftime etc. round(day, -1) ## Time difference of 20 hours # the underlying double unclass(day)[1] ## [1] 24 1.1.2.4 Lists Earlier we learned lists are just vectors of references to objects of any type. They have only attribute class “list”. Lists are created with list(). Notice they can contain references to other list, and so are called recursive vectors: l &lt;- list(1, letters[1:10], c(T,T,F,F), list(1)) str(l) ## List of 4 ## $ : num 1 ## $ : chr [1:10] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ : logi [1:4] TRUE TRUE FALSE FALSE ## $ :List of 1 ## ..$ : num 1 c() will convert vectors into lists before combining them: c(list(letters[1:3]), 1:3) %&gt;% str() ## List of 4 ## $ : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## $ : int 1 ## $ : int 2 ## $ : int 3 1.1.2.4.1 Testing and coercing lists # test for list type is.list(l) ## [1] TRUE typeof(l) ## [1] &quot;list&quot; # already seen list(), but as.list() exists as well as.list(1:4) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 # to coerce list to vector unlist(l) ## [1] &quot;1&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; ## [9] &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;1&quot; 1.1.2.5 Data frames and tibbles Data frames are the most important data structure for data analysis in R. They are built on top of lists with attributes class “data.frame”, “names” (for columns), and “row.names”; and, crucially, requires each element be a vector of equal length. Tibbles are data frames that were later developed as part of the Tidyverse. They try and optimize the default behavior of class data.frame in the following ways. 1.1.2.5.1 Creating data.frame or tbl_df data.frame() creates a data frame object from … name = vector pairs: # create character vector and add names attribute &#39;Color&#39; color &lt;- rep(x = c(&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;), times = 2) names(color) &lt;- &#39;Color&#39; df &lt;- data.frame(sock_id = 1:6, # use name = vector pairs color, # or vectors with attribute &quot;names&quot; 6:1, # or let R use defaults `1` = 1 # but non-syntactic names will be renamed without warning ) typeof(df) ## [1] &quot;list&quot; str(df) ## &#39;data.frame&#39;: 6 obs. of 4 variables: ## $ sock_id: int 1 2 3 4 5 6 ## $ color : Factor w/ 3 levels &quot;blue&quot;,&quot;red&quot;,&quot;yellow&quot;: 2 1 3 2 1 3 ## $ X6.1 : int 6 5 4 3 2 1 ## $ X1 : num 1 1 1 1 1 1 Notice data.frame automatically creates factors from character vectors. Inhibit with stringsAsFactors arguement: data.frame(letters[1:3], stringsAsFactors = FALSE) %&gt;% str() ## &#39;data.frame&#39;: 3 obs. of 1 variable: ## $ letters.1.3.: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; Like lists and matrices, data frames and tibbles have row and column names and dimensional length: # column names names(df); colnames(df) ## [1] &quot;sock_id&quot; &quot;color&quot; &quot;X6.1&quot; &quot;X1&quot; ## [1] &quot;sock_id&quot; &quot;color&quot; &quot;X6.1&quot; &quot;X1&quot; # column length length(df); ncol(df) ## [1] 4 ## [1] 4 # row names rownames(df) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; # row length nrow(df) ## [1] 6 # row and column dimensions dim(df) ## [1] 6 4 Tibbles have class “tbl_df” (as well as data.frame) which modifies their behavior. They are created similarly to data frames: library(tibble) tbl &lt;- tibble(sock_id = 1:6, # use name = vector pairs color, # or vectors with attribute &quot;names&quot; 6:1, # or let R use defaults `1` = 1, # allows non-syntactic names `1*2` = `1` * 2 # allows reference to new variables ) typeof(tbl) ## [1] &quot;list&quot; str(tbl) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 6 obs. of 5 variables: ## $ sock_id: int 1 2 3 4 5 6 ## $ color : chr &quot;red&quot; &quot;blue&quot; &quot;yellow&quot; &quot;red&quot; ... ## $ 6:1 : int 6 5 4 3 2 1 ## $ 1 : num 1 1 1 1 1 1 ## $ 1*2 : num 2 2 2 2 2 2 Tibbles can use the same methods as data tables, for example names and dimensional length: colnames(tbl); ncol(tbl) ## [1] &quot;sock_id&quot; &quot;color&quot; &quot;6:1&quot; &quot;1&quot; &quot;1*2&quot; ## [1] 5 rownames(tbl); nrow(tbl) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; ## [1] 6 Notice tibble() did not coerce factors by default, allowed non-syntactic names (enclosed in ````), and let you reference new columns as they are created. Both data frames and tibbles require equal length vector columns and will recycle values if the vector length is smaller than the max column length; however, data frames will recyle any vector that is an integer multiple of the longest column, while tibbles will only recyle scalar values. data.frame(1:4, # the longest column vector of length 4 1, # a scalar recyled 4 times 1:2 # a length 2 vector recyled 2 times ) ## X1.4 X1 X1.2 ## 1 1 1 1 ## 2 2 1 2 ## 3 3 1 1 ## 4 4 1 2 tibble(1:4, # the longest column vector of length 4 1, # a scalar recyled 4 times 1:2 # a length 2 vector recyled 2 times ) ## Error: Tibble columns must have consistent lengths, only values of length one are recycled: ## * Length 2: Column `1:2` ## * Length 4: Column `1:4` 1.1.2.5.2 Row Names Row names, a unique vector of character, can be assigned to Data frames. This idea probably arose due to data frame’s close association to numerical matrices, where storing character data along with the matrix is useful. Get and set row names with rownames(), or argument row.names on creation: df &lt;- data.frame(idx = 1:3, row.names = c(&#39;Spider Man&#39;,&#39;Batman&#39;,&#39;Red Robin&#39;)) df ## idx ## Spider Man 1 ## Batman 2 ## Red Robin 3 Row names can be used to subset data frames: df[&quot;Batman&quot;,] ## [1] 2 Tibbles do not store row names for reasons you can read here. Rather, they treat rownames as another feature of the data. The rownames argument in as_tibble() or rownames_to_column() can transform row names to a column vector. as_tibble(df, rownames = &quot;Super Hero&quot;) ## # A tibble: 3 x 2 ## `Super Hero` idx ## &lt;chr&gt; &lt;int&gt; ## 1 Spider Man 1 ## 2 Batman 2 ## 3 Red Robin 3 1.1.2.5.3 Subsetting Data frames can be subset either one dimensionaly, like a list, or two dimensionally, like a matrix. Data frame subsetting syntax can behave unexpectedly: data.frame()[,vars] will return a data frame unless vars selects only one column; it returns a vector. selecting a single column with data.frame$var will return a column starting with \\$var if $var doesn’t exist. Tibbles always return tibbles, and vectors can be returned when desired with tibble[[var]]. If a column is not found it returns an error. # data frame will select columns starting with cotton when $cotton not found df &lt;- data.frame(cotton_candy = &#39;Yum&#39;) df$cotton ## [1] Yum ## Levels: Yum # tibbles do not match columns starting with cotton as_tibble(df)$cotton ## Warning: Unknown or uninitialised column: &#39;cotton&#39;. ## NULL 1.1.2.5.4 Testing and coercion Type Testing Coercion data frame is.data.frame() as.data.frame() tibble is_tibble() as_tibble() Note that is.data.frame() will return true for tibbles as well, since tibbles are class data.frame. 1.1.2.5.5 List Columns Because data frames are built on lists, they themsevles can contain lists. So it is possible in R to have a data frame containing data frames, making it easy to organize related datasets: df &lt;- data.frame(x = 1) df$nested &lt;- list(data.frame(cool = 1:3)) class(df$nested[[1]]) ## [1] &quot;data.frame&quot; df$nested[[1]] ## cool ## 1 1 ## 2 2 ## 3 3 To include lists on creation use I(), which inhibits interpetation/conversion of objects by setting the class to “as is”: data.frame(x= 1, I(list(data.frame(1:3)))) ## x list.data.frame.1.3.. ## 1 1 1:3 Or use tibbles which can handle lists on creation without I(): tibble(x = 1, dfs = list(tibble(1:3))) ## # A tibble: 1 x 2 ## x dfs ## &lt;dbl&gt; &lt;list&gt; ## 1 1 &lt;tibble [3 x 1]&gt; 1.1.2.6 NULL NULL is a special type in R. It has no attributes and is always zero length. It is primarily used for two things: represent an empty vector c() ## NULL represent a missing vector (e.g. often default function arguments are NULL). This is different than NULL in SQL, which is more like NA, because SQL NULL and R NA represent missing elements of a vector, rather than the vector itself. Test for NULL with is.null(): is.null(NULL) ## [1] TRUE 1.1.3 Subsetting 1.1.3.1 Selecting multiple elements To select any number of elements from a vector use [ (see ?`[` for help). 1.1.3.1.1 Atomic Vectors Atomic vectors can be subset in six ways: Positive integers return elements at that position x &lt;- 11:20 x[1] ## [1] 11 x[1:3] ## [1] 11 12 13 # repeating element positions returns multiple elements x[c(1,1,10,10)] ## [1] 11 11 20 20 # real numbers are converted to integer x[c(1.1,2.2,3.3)] ## [1] 11 12 13 # order() returns integers for elements of vector x arranged in ascending or decending order order(x, decreasing = TRUE) ## [1] 10 9 8 7 6 5 4 3 2 1 # pass that integer vector into `[` to select the reordered elements of x x[order(x, decreasing = TRUE)] ## [1] 20 19 18 17 16 15 14 13 12 11 Negative integers exclude elements at that position x[-c(1,3,5,7,9)] ## [1] 12 14 16 18 20 # you can&#39;t mix positive and negative integers x[c(1,-2)] ## Error in x[c(1, -2)]: only 0&#39;s may be mixed with negative subscripts Logical vectors include or excluded elements based on values TRUE/FALSE. This allows you to pass a logical test into [: # a logical test produces a logical vector x &lt; 15 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE # this logical vector can subset elements based on TRUE/FALSE x[x&lt;15] ## [1] 11 12 13 14 # recylcing rules apply if the vector is an integer multiple of length(x) x[c(TRUE, FALSE)] ## [1] 11 13 15 17 19 # NA will always return NA in the results x[c(TRUE, NA)] ## [1] 11 NA 13 NA 15 NA 17 NA 19 NA Nothing returns the vector as is. This is more useful for 2d structures and multi-dim arrays. x[] ## [1] 11 12 13 14 15 16 17 18 19 20 Zero returns a zero-length vector. x[0] ## integer(0) Character vectors can be used to select vectors with attribute names. This does not work to factors and only selects exact matches. x &lt;- setNames(x, c(letters[11:20])) x[c(&#39;m&#39;,&#39;o&#39;,&#39;o&#39;,&#39;n&#39;)] ## m o o n ## 13 15 15 14 1.1.3.1.2 Lists Use [ to subset lists exactly as atomic vectors, only [ will ever return a list. To extract elements out of a list you need [[ or $ per below. 1.1.3.1.3 Matrices and arrays Subsetting 2d matrices and &gt;2d arrays with [ can be done with: multiple vectors (delimited with ,) m &lt;- matrix(data = 1:9, nrow = 3) m ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # pass a vector for each dimension, the first two rows and not the third column m[c(1:2),-3] ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 # empty vectors are useful now to select all elements of a dimension # select all rows and not the third column m[, -3] ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 single vectors (not delimited with ,) # matrices and arrays are just vectors with class &quot;dim&quot;, so passing single vectors is valid m[1:3] ## [1] 1 2 3 m[c(T,T,T,F,F,F,T,T,T)] ## [1] 1 2 3 7 8 9 R will simplify to the lowest dimensionality possible, so passing a vector returns a vector. Passing two dimensions returns a matrix etc. matrix # a matrix of (row, col) dimensions to select the diagonal in matrix m m_select &lt;- matrix(data = c(1,1,2,2,3,3), nrow = 3, byrow = T) m_select ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 # matrix m m ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # pass the matrix to subset the diagonal of m m[m_select] ## [1] 1 5 9 1.1.3.1.4 Data frames and tibbles Data frames can be subset with [ also, but they behave like lists when passing a vector, and like a matrix when passing multiple vectors with ,. # a data frame df &lt;- data.frame(x = 1:5, y = letters[1:5], z = LETTERS[1:5], stringsAsFactors = FALSE) df ## x y z ## 1 1 a A ## 2 2 b B ## 3 3 c C ## 4 4 d D ## 5 5 e E # passing a vector returns whole columns df[c(&quot;x&quot;,&quot;x&quot;,&quot;z&quot;)] ## x x.1 z ## 1 1 1 A ## 2 2 2 B ## 3 3 3 C ## 4 4 4 D ## 5 5 5 E # passing vector pairs for each dimension subsets like a matrix df[c(1,5), ] ## x y z ## 1 1 a A ## 5 5 e E We saw earlier that matrix subsetting will try and simplify vectors when possible. This has consequences for data frames when subsetting single columns like a matrix: # passing vector pairs may try and simplify vectors (in this case to an integer vector) str(df[,&quot;x&quot;]) ## int [1:5] 1 2 3 4 5 To preserve dimensionality use drop = FALSE: str(df[,&quot;x&quot;, drop = FALSE]) ## &#39;data.frame&#39;: 5 obs. of 1 variable: ## $ x: int 1 2 3 4 5 Tibbles will always return tibbles: str(tibble::as_tibble(df)[,&quot;x&quot;]) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 5 obs. of 1 variable: ## $ x: int 1 2 3 4 5 1.1.3.2 Selecting a single element [[ can be used for subsetting single elements, while x$y can be used similar to x[[\"y\"]]. 1.1.3.2.1 [[ Recall [ returns a list element as a list. So to access the value within that list you write [[: l &lt;- list(1, matrix(1:9,3), c(TRUE,FALSE,TRUE)) # [ returns a list str(l[3]) ## List of 1 ## $ : logi [1:3] TRUE FALSE TRUE # [[ returns the object in that list l[[3]] ## [1] TRUE FALSE TRUE 1.1.3.2.2 $ $ is a shortcut for something similar to x$y == x[[\"y\"]] and is often used to extract columns of data frames: df &lt;- data.frame(x = 1:5, yolk=letters[1:5], zoo = LETTERS[1:5]) df$x ## [1] 1 2 3 4 5 However, there is a common misuse: $ does partial matching from left-to-right. df$y # returns column name &quot;yolk&quot; ## [1] a b c d e ## Levels: a b c d e You can use options(warnPartialMatchDollar = TRUE) to warn you when it happens: options(warnPartialMatchDollar=TRUE) df$y ## Warning in df$y: partial match of &#39;y&#39; to &#39;yolk&#39; ## [1] a b c d e ## Levels: a b c d e Tibbles never do partial matching. 1.1.3.3 Subassignment Subsetting can be combined with assignment to update values at those indices. This is called subassignment and takes the general form x[i] &lt;- value. x &lt;- 1:10 # update elements 1:5 and flip their sign x[c(1:5)] &lt;- c(1:5)*-1 x ## [1] -1 -2 -3 -4 -5 6 7 8 9 10 R will recycle subassignments if the subset and assgnment vectors are different lengths, so be sure of both length and duplicate values. # R recyles the scalar to both the first and last elements x[c(1,length(x))] &lt;- 0 x ## [1] 0 -2 -3 -4 -5 6 7 8 9 0 List elements can be removed with NULL subassignment: rm(l) # Create list l where element 3 is a data frame l &lt;- list(1:3, 1, data.frame(x = 1:12)) # subassign the 3rd element to NULL l[[3]] &lt;- NULL # the data frame is removed from list l str(l) ## List of 2 ## $ : int [1:3] 1 2 3 ## $ : num 1 Empty subsets can be useful to preserve the original object class: rm(df) df &lt;- data.frame(x=c(1,1,0,0)) # modify the empty subset of the data frame rather than the data frame object # i.e. modify the contents rather than the object df[] &lt;- lapply(df, as.logical) # df retains data.frame class str(df) ## &#39;data.frame&#39;: 4 obs. of 1 variable: ## $ x: logi TRUE TRUE FALSE FALSE # whereas list apply updates df object to class list df &lt;- lapply(df, as.integer) str(df) ## List of 1 ## $ x: int [1:4] 1 1 0 0 1.1.3.4 Applications 1.1.3.4.1 Lookup tables Translating lookup values using subsetting: # a character vector of test scores scores &lt;- c(&#39;l&#39;,&#39;l&#39;,&#39;h&#39;,&#39;m&#39;,&#39;h&#39;,&#39;m&#39;,&#39;l&#39;) # a lookup vector of descriptors for named scores xlat_scores &lt;- c(l = &#39;low&#39;,m = &#39;medium&#39;, h=&#39;high&#39;) # subset xlat_scores with the observed scores xlat_scores[scores] ## l l h m h m l ## &quot;low&quot; &quot;low&quot; &quot;high&quot; &quot;medium&quot; &quot;high&quot; &quot;medium&quot; &quot;low&quot; # or unname() to remove attribute &quot;names&quot; unname(xlat_scores[scores]) ## [1] &quot;low&quot; &quot;low&quot; &quot;high&quot; &quot;medium&quot; &quot;high&quot; &quot;medium&quot; &quot;low&quot; 1.1.3.4.2 Matching and merging by integer subsetting To merge multiple columns from a lookup table manually you can use match(), which matches elements of x in table (see ?match()) and returns the integer position in table: pets &lt;- c(1,2,1,3) pet_xlat &lt;- data.frame(petid = c(3,2,1), pet.type = c(&#39;cat&#39;,&#39;dog&#39;,&#39;bird&#39;), pet.aka = c(&#39;kitty&#39;,&#39;doggie&#39;,&#39;birdie&#39;)) pet_match &lt;- match(x = pets, table = pet_xlat$petid) # the matching integer position of pets in pet_xlat pet_match ## [1] 3 2 3 1 # subset the rows matched by pet_match pet_xlat[pet_match,] ## petid pet.type pet.aka ## 3 1 bird birdie ## 2 2 dog doggie ## 3.1 1 bird birdie ## 1 3 cat kitty rm(pets) rm(pet_xlat) rm(pet_match) To merge on more than one column you would typically use interaction() to collapse into one and perform a similar operation. However, you should probably look to custom built merge functions like merge() or dplyr::left_join() to ease the process. 1.1.3.4.3 Random and Bootstrap sampling Data frame subsetting makes it easy to create random samples and bootstrap samples in R. sample() returns elements of a vector (or creates an integer vector 1:n if given a scalar) with arguments for size= and replace=. rm(df) df &lt;- data.frame(x = 1:5, y = letters[1:5], z = LETTERS[1:5], stringsAsFactors = FALSE) set.seed(1) # use integer indices from sample to return two randomly sampled rows from df without replacement df[sample(5, size = 2),] ## x y z ## 1 1 a A ## 4 4 d D # use sample() to randomly sample an integer vector 1:length(df) with replacement 5 times # and subset the corresponding rows of df set.seed(1) df[sample(x = length(df), size = 5, replace = TRUE), ] ## x y z ## 1 1 a A ## 3 3 c C ## 1.1 1 a A ## 2 2 b B ## 1.2 1 a A # row 1 was selected three times (rownames: 1, 1.1, 1.2), and rows 2 &amp; 3 only once in a bootstrap sample rm(df) 1.1.3.4.4 Ordering Use order() to return an integer vector describing the sorted elements of x or ..., which can be used to subset vectors in a new order: x &lt;- letters[10:1] x ## [1] &quot;j&quot; &quot;i&quot; &quot;h&quot; &quot;g&quot; &quot;f&quot; &quot;e&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot; # order() returns the integer positions of x sorted ascending by default order(x) ## [1] 10 9 8 7 6 5 4 3 2 1 # use this new vector to reorder the original vector x[order(x)] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; rm(x) There are additional arguments to order() such as decreasing and na.last that allow you to sort descending or NA values first, last, or ommit them. For &gt;2d vectors, order() can be passed to each dimension allowing you to sort columns and rows independently: df &lt;- data.frame(Alpha = 1:6, Bravo = TRUE, Charlie = c(&#39;red&#39;,&#39;blue&#39;,NA)) df ## Alpha Bravo Charlie ## 1 1 TRUE red ## 2 2 TRUE blue ## 3 3 TRUE &lt;NA&gt; ## 4 4 TRUE red ## 5 5 TRUE blue ## 6 6 TRUE &lt;NA&gt; # subset df by sorting rows by Charlie and removing NA; order columns descending by name df[order(df$Charlie, na.last = NA), order(names(df), decreasing = T)] ## Charlie Bravo Alpha ## 2 blue TRUE 2 ## 5 blue TRUE 5 ## 1 red TRUE 1 ## 4 red TRUE 4 1.1.3.4.5 Random sort As an extension of ordering, use sample() to randomly reorder rows of a data frame: set.seed(8) # randomly sample integers from 1:&quot;rows in df&quot; &quot;rows in df&quot; times without replacement # and subset row dim df[sample(nrow(df), nrow(df), replace = FALSE), ] ## Alpha Bravo Charlie ## 4 4 TRUE red ## 2 2 TRUE blue ## 3 3 TRUE &lt;NA&gt; ## 6 6 TRUE &lt;NA&gt; ## 5 5 TRUE blue ## 1 1 TRUE red rm(df) 1.1.3.4.6 Expanding aggregate counts rep() replicates elements of x a number of times, where times can be a vector for each element, or a scalar to recyle the entire vector x. rep() also can accept argument each to repeat each element each number of times instead of recycling the entire vector; or length.out to recyle the vector the desired length (even if not an integer multiple). df &lt;- data.frame(crayon_color = c(&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;), count = 1:3) df ## crayon_color count ## 1 red 1 ## 2 blue 2 ## 3 yellow 3 # rep() accepts an integer vector and vector `times` as the number to repeat each element rep(x = 1:nrow(df), times = df$count) ## [1] 1 2 2 3 3 3 # used to subset rows in df expands the aggregate counts into observations df[rep(1:nrow(df), df$count),] ## crayon_color count ## 1 red 1 ## 2 blue 2 ## 2.1 blue 2 ## 3 yellow 3 ## 3.1 yellow 3 ## 3.2 yellow 3 rm(df) 1.1.3.4.7 Removing data frame columns Data frame columns can be removed in two ways, by setting the column to NULL or by subsetting/subassigning the columns you do want: df &lt;- mtcars[1:4] df$mpg &lt;- NULL str(df) ## &#39;data.frame&#39;: 32 obs. of 3 variables: ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... df &lt;- df[c(&#39;cyl&#39;,&#39;hp&#39;)] str(df) ## &#39;data.frame&#39;: 32 obs. of 2 variables: ## $ cyl: num 6 6 4 6 8 6 8 4 4 6 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... rm(df) You can use set operations to select all except the columns you don’t want: df &lt;- mtcars[1:4] yuck &lt;- c(&quot;cyl&quot;,&quot;disp&quot;) # setdiff() returns the unique names found in names(df) and not contained in set yuck head(df[setdiff(names(df),yuck)]) ## mpg hp ## Mazda RX4 21.0 110 ## Mazda RX4 Wag 21.0 110 ## Datsun 710 22.8 93 ## Hornet 4 Drive 21.4 110 ## Hornet Sportabout 18.7 175 ## Valiant 18.1 105 rm(df) 1.1.3.4.8 Logical subsetting The most common subsetting action for data frames is passing a logical vector to the row dimension of [. This allows for multiple conditions accross column vectors using ( grouping for clarity, and vector boolean operators &amp; (and), | (or), ! (not), %in% (in), etc. # select cars that get over 20 mpg, are not 4 cylinder, and are not the Honda Civic # or Hornet 4 Drive mtcars[(mtcars$mpg &gt; 20) &amp; (mtcars$cyl != 4) &amp; !(rownames(mtcars) %in% c(&#39;Honda Civic&#39;, &#39;Hornet 4 Drive&#39;)),] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 1.1.3.4.9 Boolean algebra and sets Logical subsetting (boolean) and integer subsetting (sets) are naturally equivocal. However, integer sets may have an advantage when you specifically need the location of the first or last TRUE element of a set, if the logical set contains a high ratio of FALSE:TRUE (you may save on memory), or if you specifically want the results to drop NAs. You can use which() to convert a logical set to an integer set: # a logical set l &lt;- c(FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, NA) # an integer set--which() gives the TRUE indices of a logical vector and *drops all NA* i &lt;- which(l) i ## [1] 2 5 6 7 You might convert a logical to an integer set to easily find the first or last TRUE elements: # first TRUE i[1] ## [1] 2 # last TRUE i[length(i)] ## [1] 7 rm(l); rm(i) Boolean compared to set oprations # set x; create logical and integer versions x1 &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE) x2 &lt;- which(x1); x2 ## [1] 1 3 5 # set y; create logical and integer versions y1 &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE) y2 &lt;- which(y1); y2 ## [1] 1 4 Intersection: &amp; \\(\\Leftrightarrow\\) intersect() # both must be TRUE x1 &amp; y1 ## [1] TRUE FALSE FALSE FALSE FALSE FALSE intersect(x2, y2) ## [1] 1 Union: | \\(\\Leftrightarrow\\) union() # either can be TRUE x1 | y1 ## [1] TRUE FALSE TRUE TRUE TRUE FALSE union(x2, y2) ## [1] 1 3 5 4 Complement: &amp; ! \\(\\Leftrightarrow\\) setdiff() # exclusive TRUE in x1 x1 &amp; !y1 ## [1] FALSE FALSE TRUE FALSE TRUE FALSE setdiff(x2, y2) ## [1] 3 5 Symmetric difference: xor() \\(\\Leftrightarrow\\) setdiff(union(), intersect()) # exclusive or (either is TRUE but only one) xor(x1, y1) ## [1] FALSE FALSE TRUE TRUE TRUE FALSE setdiff(union(x2, y2), intersect(x2, y2)) ## [1] 3 5 4 1.1.4 Control Flow Control flows in R can be split into choices and loops. Technically, conditions like messages, warnings, and erros offer a non-local form a control flow (see conditions). 1.1.4.1 Choices if takes the basic form of: if (condition) true_action if (condition) true_action else false_action It returns the value of true_action or false_action; and can be compounded within { to peform multiple tests: x &lt;- 2 # if (condition) evaluates a scalar if (x == 1) &quot;single&quot; else &quot;multiple&quot; ## [1] &quot;multiple&quot; # compound if statments takes the form: if (x == 1){ &quot;single&quot; }else if(x == 2){ &quot;double&quot; }else{ &quot;multiple&quot; } ## [1] &quot;double&quot; if will silently return NULL when no else statement is given: presence &lt;- TRUE if (!presence) &quot;Elvis has left the building.&quot; 1.1.4.1.1 Vectorized if if only works with a single TRUE/FALSE. You can use ifelse() to vectorize if: x &lt;- 1:5 ifelse(test = x %in% c(1,2), yes = 0, no = x) ## [1] 0 0 3 4 5 To vectorize compound if statements use dplyr::case_when() (note the syntax change): set.seed(1) test_scores &lt;- rnorm(n = 5, mean = 82, sd = 10) # case_when() uses (conditional) ~ result syntax; TRUE ~ &quot;F&quot; is equivelant to else{} dplyr::case_when( test_scores &gt; 90 ~ &quot;A&quot;, test_scores &gt; 80 ~ &quot;B&quot;, test_scores &gt; 70 ~ &quot;C&quot;, test_scores &gt; 60 ~ &quot;D&quot;, TRUE ~ &quot;F&quot; ) ## [1] &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;A&quot; &quot;B&quot; 1.1.4.1.2 switch() statement switch() statements give you a more succint form of compound if{} syntax: greeting &lt;- function(person){ switch(person, swab = , captain = , pirate = , privateer = , buccaneer = , sailor = &quot;Ahoy&quot;, stop(&quot;It&#39;s mutiny!&quot;) ) } greeting(person = &quot;privateer&quot;) ## [1] &quot;Ahoy&quot; greeting(person = &quot;taxidermist&quot;) ## Error in greeting(person = &quot;taxidermist&quot;): It&#39;s mutiny! when no value is defined switch() will “fall through” to the next defined value (e.g. “Ahoy”) the last argument uses stop() to throw an error; else switch() will return NULL and fail silently switch() can throw undesirable errors when used with numeric, so it’s advisable to only use it with type character. 1.1.4.2 Loops note: loops are generally not needed for data anlysis tasks as there are functionals (e.g. map() and apply()) which vectorize them for you. for is an iterator which takes each element of a vector until either there are no elements left, or next/break is encountered. It takes the form: for (item in vector) perform_action # or can be extended to compound statements similar to `if`: for (item in vector){ action_1 action_2 etc. } i in this example is a binding within {} environment of the current vector element, and will be overwritten each iteration: for (i in letters[1:3]) print(i) ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; for (i in letters[1:10]){ if (i == &quot;b&quot;) next if (i == &quot;d&quot;) break print(i) } ## [1] &quot;a&quot; ## [1] &quot;c&quot; Why your for loop is slow: Because of dynamic memory allocation, it is better in R to pre-allocate vector containers so the program is not repeatedly asking for more and more memeory as the object grows. It also minimizes the number of object copies required. vector() can be used to create the vector container of the right type and length: # create an integer vector the same length as our loop v &lt;- vector(mode = &quot;integer&quot;, length = 10) v ## [1] 0 0 0 0 0 0 0 0 0 0 # R has already allocated space for vector v, so updating each element with `for` # does for (i in 1:10){ v[i] &lt;- i } v ## [1] 1 2 3 4 5 6 7 8 9 10 seq_along() instead of 1:length() It is better to generate a regular sequence with seq_along() because it will always generate a numeric sequence the same length as the input vector. 1:length(x) can fail when vector length is 0 because : will actually create vector [1] 1 0 (since : creates descending vectors as well). v &lt;- c() # error here when accessing vector position 0, which, in R, doesn&#39;t exist for (i in 1:length(v)){ v[[i]] &lt;- i } ## Error in v[[i]] &lt;- i: attempt to select less than one element in integerOneIndex dropping S3 object attributes It is easy to drop object attributes when iterating, as for will loop the underlying, in this case, double values: v &lt;- as.Date(x = c(&#39;2020-04-01&#39;,&#39;2020-04-02&#39;)) for (i in v){ print(i) } ## [1] 18353 ## [1] 18354 You can use seq_along() and access the element directly using [[ to avoid droping attributes: v &lt;- as.Date(x = c(&#39;2020-04-01&#39;,&#39;2020-04-02&#39;)) for (i in seq_along(v)){ print(v[[i]]) } ## [1] &quot;2020-04-01&quot; ## [1] &quot;2020-04-02&quot; 1.1.4.2.1 Other loops Other loops in R: while (condition) do_action: this is more flexible than loops because you don’t have to know the length of the vector apriori. repeat(do_action): where do_action repeats forever until it encounters break 1.1.5 Functions Functions are first-class objects in R you create with function(). They can be bound to a name or left anonymous; and have three components: 1.1.5.1 Function Components Arguments: formals() are arguments passed to the function that determine how it is called Body: body() the code being called Environment: environment() a data structure that determines how R finds bound values within the function Arguments and body are always specified explicitly in the function, and environment is implicitly specified based on where you define the function. f &lt;- function(x, y, z){ # comment within the function x + y + z } # to see the arguments formals(f) ## $x ## ## ## $y ## ## ## $z # to see the body body(f) ## { ## x + y + z ## } # to see the environment environment(f) ## &lt;environment: R_GlobalEnv&gt; Because functions are objects, they can have attributes just like vectors. Base R functions have attribute srcref, which points to the source code of the function. It is more compact for printing and includes things like comments. Use attr(), or, simply, the name of the function, i.e. without calling the function using (: { attr(f, which = &#39;srcref&#39;) f } ## function(x, y, z){ ## # comment within the function ## x + y + z ## } 1.1.5.2 Primitives Some base R functions like sum()/[ are “primitive functions”, meaning they are written in C for speed: `[` ## .Primitive(&quot;[&quot;) sum ## function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) 1.1.5.3 Anonymous functions and Closures Functions without binding names are called anonymous functions: # lapply calls a function on each element of a list. In this case each element is a # vector in a data frame. The anonymous function uses control flow to sum each vector # if it is numeric. lapply(iris, function(x) if (is.numeric(x)) sum(x)) ## $Sepal.Length ## [1] 876.5 ## ## $Sepal.Width ## [1] 458.6 ## ## $Petal.Length ## [1] 563.7 ## ## $Petal.Width ## [1] 179.9 ## ## $Species ## NULL In R you will often see functions referred to as closures because they enclose their environment. e.g. a binding within the function environment is not available globally. 1.1.5.4 Invoking functions Functions are invoked by enclosing arguments withing ( following the function binding (e.g. sum(x)). However, if you have the function arguments in a list you can envoke the function using do.call(): do.call(what = rep, args = list(x = 1:3, each = 2)) ## [1] 1 1 2 2 3 3 1.1.5.5 Function Composition There are three ways to compose function transformations: Nesting: function_b(function_a(x, y), z) Functions are nested and the result of the inner function informs an argument of the outer. This can be difficult to read, inside-out, right-to-left, and can spread agruments away from the name being called. Intermediate objects: {result &lt;- function_a(x, y); result &lt;- function_b(result, z)} With intermediate objects the function results are saved to a common binding. This is more verbose and a weakness when the results are truly temporary. Pipes: x %&gt;% function_a(y) %&gt;% function_b(z) Pipes are a way to pass objects into the first argument of a function. x %&gt;% f() is equivelant to f(x), so x %&gt;% f(y) is equivelant to f(x, y). This is analogous to treating an object as a noun and functions as verbs, allowing you to write linear chains left-to-right, similar to F# and Haskell. Data analysis workflows are often multiple linear transformations of the same object, e.g. a dataframe. 1.1.5.6 Lexical scoping Scoping is how a program finds the value associated with a name. R uses lexical scoping, which means the scoping rules are parse-time2 rather than run-time. Lexical scoping follows the following four rules: 1.1.5.6.1 Name masking With lexical scoping names defined within a function mask values found outside of that environment. R will look one level up to find the value if not defined in the environment. One level up could mean an outer function, the global environment, or, finally, any loaded packages. # bind x, y, z in the global environment x &lt;- 1; y &lt;- 2; z &lt;- 3 f &lt;- function(){ # bind y, z within the environment for f y &lt;- 20; z &lt;- f2 &lt;- function(){ # bind z within the environment for f2 z &lt;- 300 # return a vector containing each variable c(x, y, z) } # return f2 f2() } f() ## [1] 1 20 300 1.1.5.6.2 Functions vs variables Just as with variables, functions can mask other functions: # bind f in the global environment f &lt;- function() 1 f2 &lt;- function(){ # bind f in the funciton environment f &lt;- function() 100 # return f f() } f2() ## [1] 100 It is possible, in two different environments, for a variable and function to share the same name. How R scopes these values becomes more complex, because, in a function call (e.g.f()) R will ignore non-function objects when scoping that name. So it is possible for a name to represent more than one value. This is confusing and is best avoided. # bind f a function in the global environment f &lt;- function(x) x f2 &lt;- function(){ # bind f a scalar f &lt;- 100 # f represents both a variable and a function when calling f() because f() specifically # scopes for function objects only f(f) } f2() ## [1] 100 1.1.5.6.3 Variable lifespan Objects defined wihtin the environment of a function only exist while the function is invoked: # create a function either to instantiate a scalar integer or add to it f &lt;- function(){ if (!exists(&quot;a&quot;)){ a &lt;- 1 }else{ a &lt;- a + 1 } a } # both function calls return 1 because environment variables in the function are # rewritten at each function call f() ## [1] 1 f() ## [1] 1 1.1.5.6.4 Dynamic lookup Lexical scoping determines where, but not when, a value is retrieved. This can change the value a function returns because R does not scope the object until it is called: f &lt;- function(){ x * 2 } x &lt;- 1 f() ## [1] 2 x &lt;- 2 f() ## [1] 4 codetools::findGlobals() can be used to find names in a function that are externally unbound. R uses lexical scoping to find everything, including objects that may not be obvious like + and [. 1.1.5.7 Lazy evaluation R does not compute an expression until it is needed. This is called lazy evaluation: f &lt;- function(x){ message(&quot;The function doesn&#39;t stop because x is not used in f().&quot;) } f(stop(&#39;Let me outa here!&#39;)) ## The function doesn&#39;t stop because x is not used in f(). 1.1.5.7.1 Promises Lazy evaluation is powered by a data structure called a promise, which has three components: the expression (e.g. x + y), an environment, and a value (which is cached and calculated only once). 1.1.5.7.2 Default arguments You can use lazy evaluation to pass default arguments or reference variables later defined in the function. This is common in base R. However, this can be confusing because variables in the function call are otherwise scoped outside the function environment. For example, a and b are not scoped from the global environment (1e6) because we reference them as variables in the default argument z. Also, default arguments can reference other default arguments (see x), even if later defined in the function (a and b): # a &amp; b are defined in the global environment a &lt;- 1e6 b &lt;- 1e6 # use = to define the default argument # default arguments can reference other arguments, even if defined later in the function f &lt;- function(x = 1, y = 1 + x, z = a * b){ a &lt;- 3 b &lt;- 1 c(x, y, z) } f() ## [1] 1 2 3 1.1.5.7.3 Missing arguments missing() can tell you if an argument was given by the user or was default: f &lt;- function(x = 1){ missing(x) } # TRUE; x was missing and the default value used f() ## [1] TRUE # FALSE; x was given to the function call f(1) ## [1] FALSE Read ?missing() carefully because there are a lot of “gotchas” with missing() in base R. For example, read sample–sample() will assign a value for argument size even though it has no default argument. 1.1.5.7.3.1 %||% infix function This common pattern, if (missing(x)) x &lt;- object, in base R functions can be simplified by the %||% infix function from rlang. Instead of pretending an argument is required, set the default argument to NULL: library(rlang) ## Warning: package &#39;rlang&#39; was built under R version 3.6.3 # %||% is relatively simple; if left side is NULL return right side else return left side function (x, y) { if (is_null(x)) y else x } ## function (x, y) ## { ## if (is_null(x)) ## y ## else x ## } # in this example, it&#39;s explicit x is optional and control flow is concise if NULL f &lt;- function(x = NULL){ x %||% 7 } f() ## [1] 7 1.1.5.8 ... (dot-dot-dot) ... in other languages is often called varargs (variable arguments). In R it’s called “dots”. It allows functions to take any number of additional arguments: # f only takes 3 arguments, so calling with 4 returns an error f &lt;- function(x, y, z){ c(x,y,z) } f(1,2,3,4) ## Error in f(1, 2, 3, 4): unused argument (4) # ... allows you to pass more arguments f &lt;- function(x, y, z, ...){ c(x,y,z) } f(1,2,3,4) ## [1] 1 2 3 When creating a functional and passing dots use ... in the sub-functions requiring them: # create functional to return aggregate of random samples from a distribution (rnorm, runif, rt etc) functional &lt;- function(f, distr, ... ){ f(distr(...)) } functional(f = sum, distr = rnorm, n = 100, mean = 7, sd = 2) ## [1] 678.5773 The primary use of ... is to pass additional arguments to other functions or methods. For example, lapply() applys a function over each element of a list. In this case, I’m using the ... argument of lapply() to pass the trim argument to mean(): lapply(X = mtcars[1:2], FUN = mean, trim = .25) ## $mpg ## [1] 19.175 ## ## $cyl ## [1] 6.375 It is possible to use ..N to specify the position of the additional arguments: # this function returns the first three additional arguments in reverse order f &lt;-function(...){ c(..3, ..2, ..1) } f(1,2,3) ## [1] 3 2 1 However, it may be more useful to store them in a list: f &lt;-function(...){ list(...) } # a list of the additional arguments (with name if defined) str(f(arg1 = 1, arg2 = 2, 3)) ## List of 3 ## $ arg1: num 1 ## $ arg2: num 2 ## $ : num 3 Beware that misspelled arguments does not raise an error: # mean argument trim is mispelled and therfor silently dropped lapply(mtcars[&quot;mpg&quot;], mean, trimm = .25) ## $mpg ## [1] 20.09062 1.1.5.9 Exiting a function Most functions exit by either returning a value or throwing an error. 1.1.5.9.1 Explicit vs implicit R will implicitly return the last value encountered, or you can explicitly define the return with return(): f &lt;- function(x){ x*2 x } f(1) ## [1] 1 f &lt;- function(x){ return(x*2) x } f(1) ## [1] 2 1.1.5.9.2 Visible vs invisible Functions return values visibly by default (i.e. they get printed); however, you can turn this off with invisible(). The value still is return, just not printed: f &lt;- function(x) invisible(x) f(2) # enclosing with () forces print; showing the value is indeed returned (f(2)) ## [1] 2 &lt;-, plot(), print() or any function that exists primarily for a side-effect, the value should be returned invisibly. This is what allows x &lt;- y &lt;- 2 type assignment chaining. 1.1.5.9.3 Errors stop() should be used to halt and exit a function if it cannot be completed: f &lt;- function(x){ if (is.numeric(x)) sum(x) else stop(&#39;x must be numeric.&#39;) } f(&quot;banjos&quot;) ## Error in f(&quot;banjos&quot;): x must be numeric. 1.1.5.9.4 Exit handlers Sometimes you modify objects in a function which need to be cleaned up whether the code executes successfully or not. Use on.exit(add = TRUE): old_dir &lt;- getwd() old_dir ## [1] &quot;C:/Users/hickmancr/Desktop/ChaseHickman&quot; f &lt;- function(x, ...){ if (x){ # set working directory to one level up setwd(&#39;..&#39;) # reset the original working directory whether the function executes or not on.exit(setwd(old_dir), add = TRUE) getwd() }else{ stop(&quot;You&#39;re not my supervisor!&quot;) } } f(FALSE) ## Error in f(FALSE): You&#39;re not my supervisor! # on.exit() cleaned up the working directory even though the function threw an error getwd() ## [1] &quot;C:/Users/hickmancr/Desktop/ChaseHickman&quot; on.exit() can be called from anywhere in the function, so it’s helpful to place it next to the code to be cleaned up. User after argument to help order the execution of on.exit(). It’s important to set add = TRUE or each exit handler will overwrite the previous! 1.1.5.10 Function forms Every action in R is a function call. They take four forms: Prefix: function(x, y) where the name comes before the arguments Infix: x + y where the name comes between the arguments Replacement: function(x) &lt;- updates values by assignment Specials: [[, for, if etc. have non standard structures All functions can be written in prefix form, however (e.g. `+`(x, y)) 1.1.5.10.1 Prefix form function(x, y) where the name comes before the arguments. This is the most common function form in R and beyond. Arguments are mached exact name &gt; unique prefix &gt; position: f &lt;- function(x, yellow, zoo, zoom){ l &lt;- list(x, yellow, zoo, zoom) str(l) } # error because zo could be partially matching zoo or zoom f(yel = 2, zo = 3, 4, x = 1) ## Error in f(yel = 2, zo = 3, 4, x = 1): argument 2 matches multiple formal arguments # R matches unspecified arguments by position f(yel = 2, 3, 4, x = 1) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 1.1.5.10.2 Infix form x + y where the name comes inbetween the arguments, and therefor take two arguments composed left to right. A full list of base infix functions and their rank, which determines the order R processes the functions. You can assign your own infix functions using %{var}% form using any characters except %. Special characters have to be escaped when assigning, but not when calling infix functions. `%\\\\%` &lt;- function(x,y) paste0(&#39;I don\\&#39;t know; &#39;, x + y, &#39;?&#39;) 1 %\\% 2 ## [1] &quot;I don&#39;t know; 3?&quot; + and - are two infix functions that can be called with only one argument. 1.1.5.10.3 Replacement form Replacement functions appear to update their value in place, names() &lt;-, but they actually do create object copies you can see with tracemem(). They must take the general form: `function_name&lt;-` &lt;- function(x, value) where x and value must be the first and last arguments, with addition arguments inbetween if needed, and must return x: # create replacement function to modify even position elements of a vector `evens&lt;-` &lt;- function(x, value){ x[1:length(x) %% 2 == 0] &lt;- value x } v &lt;- 1:5 # could be expressed as evens(x = v, value = 0) evens(v) &lt;- 0 v ## [1] 1 0 3 0 5 1.1.5.10.4 Specials Everything else in R fall under the special form, including control flow (if,for, break etc), subsetting operators ([, [[), parentheses and braces ((,{), function etc. Anything you have questions about refer to `?function_name``` 1.1.6 Environments Environments 1.1.7 Conditionals Conditionals 1.1.8 Functionals Functionals take a function as input and return a vector. The are commonly used in place of for loops. # apply a function to all even elements of a vector x # use dots (...) to pass additional arguments to function evens &lt;- function(x, f, ...){ f(x[x%%2==0], ...) } # passes na.rm=TRUE on to sum evens(1:4, f = sum, na.rm=TRUE) ## [1] 6 evens(1:10, f = length) ## [1] 5 1.1.8.1 lapply() and purrr::map() lapply() and purrr::map() are ubiquitous functionals. They take either an atomic or list vector and apply a function to each element and return a list: library(magrittr) library(purrr) ## ## Attaching package: &#39;purrr&#39; ## The following object is masked from &#39;package:magrittr&#39;: ## ## set_names f &lt;- function(x) x*2 lapply(1:3, f) %&gt;% str() ## List of 3 ## $ : num 2 ## $ : num 4 ## $ : num 6 map(1:3, f) %&gt;% str() ## List of 3 ## $ : num 2 ## $ : num 4 ## $ : num 6 To predict what the apply family of functionals can do it’s important to consider the input and output vectors. Atomic vs List Vector input As lapply() or map() iterate through each vector element be aware of the object actually being passed. You might be iterating over each value in an atomic vector, or, with a list, potentially any R object (e.g. each atomic vector in a dataframe). 1:10 %&gt;% .[[1]] ## [1] 1 list(matrix(1:4, 2), TRUE, 1:10) %&gt;% .[[1]] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Atomic vs List Vector output lapply() and map() both return lists, which can contain any R object. So there is no limit to the objects returned by the function being applied. However, other functionals in the apply() and map() family can return simplified objects like atomic vectors, in which case the applied function must return a single value of consistent type: # aggregate functions are okay because they return single values vapply(mtcars[1:3], function(x) sum(x), FUN.VALUE = double(1)) ## mpg cyl disp ## 642.9 198.0 7383.1 # this function errors because it would return an atomic vector, which cannot be an # element of an atomic vector vapply(mtcars[1:3], function(x) x*2, FUN.VALUE = double(1)) ## Error in vapply(mtcars[1:3], function(x) x * 2, FUN.VALUE = double(1)): values must be length 1, ## but FUN(X[[1]]) result is length 32 1.1.8.1.1 Returning atomic vectors To simplify the object type return from map(), purrr has the following map_*() functionals: # character map_chr(letters[1:4], function(x) toupper(x)) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; # logical map_lgl(list(1:3, letters[1:3]), is.numeric) ## [1] TRUE FALSE # double map_dbl(mtcars, function(x) if (max(x) &lt;= 8) max(x) else NA) ## mpg cyl disp hp drat wt qsec vs am gear carb ## NA 8.000 NA NA 4.930 5.424 NA 1.000 1.000 5.000 8.000 # integer map_int(list(1:3, T, letters[1:3]), length) ## [1] 3 1 3 Using map() may be helpful when debugging map_*(), as you could expect the list and see where invalid values were returned. vapply() in base R is similar in that you can return an atomic vector of a specific type with argument FUN.VALUE: # FUN.VALUE must be a vector of the type you want returned, usually length 1 to # indicate that the return value should be the same length as x; see ?vapply vapply(list(1:3, letters[1:3]), is.character, FUN.VALUE = logical(1)) ## [1] FALSE TRUE Avoid sapply() as the simplified value may return different types. 1.1.8.1.2 Anonymous functions and purrr formulas Anonymous functions can be used in the functional call, i.e. a function with no bound name. purrr functions accepts a special, shorter syntax for creating anonymous functions. It converts formulas (~) to anonymous functions using .x/..1, .y/..2, ..3 etc arguments: map_dbl(1:3, ~ .x * .y, 10) ## [1] 10 20 30 # use as_mapper() to peer into the function created as_mapper(~ .x * .y) ## &lt;lambda&gt; ## function (..., .x = ..1, .y = ..2, . = ..1) ## .x * .y ## attr(,&quot;class&quot;) ## [1] &quot;rlang_lambda_function&quot; &quot;function&quot; purrr also makes it easy to extract elements from lists by position, name, and/ name and position using the same functions, even when the lists are heavily nested: x &lt;- list( list(&quot;1&quot;, a = 2.1, c = c(1.1,2.1)), list(&quot;2&quot;, a = 2.2, c = c(1.2,2.2)) ) map_chr(x, 1) ## [1] &quot;1&quot; &quot;2&quot; map_dbl(x, &quot;a&quot;) ## [1] 2.1 2.2 map_dbl(x, list(&quot;c&quot;,2)) ## [1] 2.1 2.2 1.1.8.1.3 … (dots) for passing arguments In lapply() and map() additional arguments can be passed into function via ...: # na.rm=TRUE is passed into function sum via dots lapply(X = list(c(1,2,NA)), FUN = sum, na.rm=TRUE) ## [[1]] ## [1] 3 decomposition ... are not decomposed; meaning, for example, if you were to pass a vector using ... then the entire vector would be evaluated per function call, i.e. elements are not iterated in parallel with X: # for each element in 1:3, sum the vector passed in the second additonal argument .y # if .y were decomposed, it would return 3, 2, 1 map_dbl(1:3, ~ sum(.y), 3:1) ## [1] 6 6 6 ... passed arguments vs intra-function arguments Additional arguments are only evaluated once in a named function, but evaluated per function call in anonymous functions: # since .y is passed via ... it is only evaluated once map_dbl(c(1,1,1), ~ .x * .y, .y=runif(1)) ## [1] 0.3513488 0.3513488 0.3513488 # since .y is defined within the function, it is re-evaluated each time map_dbl(c(1,1,1), ~ .x * runif(1)) ## [1] 0.2566184 0.3698173 0.4780058 1.1.8.1.4 Apply as for loop generator This is simply to document a creative use of lapply and map that might otherwise go unoticed. generating random data Map over a vector, not to transform the vector, but to thrice run a function generating data frames of random, normally distributed data sets. Mean and sd are defined within the function so it reevaluates each call: rnorm.data &lt;- map(1:3, function(.x){ mean = c(-100:100)[sample(length(-100:100), size = 1)] sd = c(0:20)[sample(length(0:10), size = 1)] data.frame(rnorm = rnorm(n=10, mean=mean, sd = sd), mean=mean, sd=sd) } ) str(rnorm.data) ## List of 3 ## $ :&#39;data.frame&#39;: 10 obs. of 3 variables: ## ..$ rnorm: num [1:10] -43.8 -44.8 -45.2 -43.7 -47 ... ## ..$ mean : int [1:10] -45 -45 -45 -45 -45 -45 -45 -45 -45 -45 ## ..$ sd : int [1:10] 5 5 5 5 5 5 5 5 5 5 ## $ :&#39;data.frame&#39;: 10 obs. of 3 variables: ## ..$ rnorm: num [1:10] 6.1 5.48 6.42 4.91 7.77 ... ## ..$ mean : int [1:10] 6 6 6 6 6 6 6 6 6 6 ## ..$ sd : int [1:10] 1 1 1 1 1 1 1 1 1 1 ## $ :&#39;data.frame&#39;: 10 obs. of 3 variables: ## ..$ rnorm: num [1:10] -38.3 -38.2 -38.7 -36.9 -35.8 ... ## ..$ mean : int [1:10] -38 -38 -38 -38 -38 -38 -38 -38 -38 -38 ## ..$ sd : int [1:10] 1 1 1 1 1 1 1 1 1 1 Accessing related elements accross a data frame You can apply a function using a 1:n vector to subset dataframes by row index. In the example below using mtcars, this allows me to calculate the mean mpg only of cars which have a higher number of cylinders than the one being observed: vapply(1:nrow(mtcars), function(i) mtcars[mtcars$cyl &gt; mtcars[i,&#39;cyl&#39;],&#39;mpg&#39;] %&gt;% mean() %&gt;% round(1), FUN.VALUE = double(1)) %&gt;% cbind(mtcars[,c(&#39;mpg&#39;,&#39;cyl&#39;)]) ## . mpg cyl ## Mazda RX4 15.1 21.0 6 ## Mazda RX4 Wag 15.1 21.0 6 ## Datsun 710 16.6 22.8 4 ## Hornet 4 Drive 15.1 21.4 6 ## Hornet Sportabout NaN 18.7 8 ## Valiant 15.1 18.1 6 ## Duster 360 NaN 14.3 8 ## Merc 240D 16.6 24.4 4 ## Merc 230 16.6 22.8 4 ## Merc 280 15.1 19.2 6 ## Merc 280C 15.1 17.8 6 ## Merc 450SE NaN 16.4 8 ## Merc 450SL NaN 17.3 8 ## Merc 450SLC NaN 15.2 8 ## Cadillac Fleetwood NaN 10.4 8 ## Lincoln Continental NaN 10.4 8 ## Chrysler Imperial NaN 14.7 8 ## Fiat 128 16.6 32.4 4 ## Honda Civic 16.6 30.4 4 ## Toyota Corolla 16.6 33.9 4 ## Toyota Corona 16.6 21.5 4 ## Dodge Challenger NaN 15.5 8 ## AMC Javelin NaN 15.2 8 ## Camaro Z28 NaN 13.3 8 ## Pontiac Firebird NaN 19.2 8 ## Fiat X1-9 16.6 27.3 4 ## Porsche 914-2 16.6 26.0 4 ## Lotus Europa 16.6 30.4 4 ## Ford Pantera L NaN 15.8 8 ## Ferrari Dino 15.1 19.7 6 ## Maserati Bora NaN 15.0 8 ## Volvo 142E 16.6 21.4 4 1.1.8.2 Purrr style Below is an example of using chained purrr functionals to solve a data analysis problem. I want to extract \\(\\beta_1\\) coefficients from linear models of each sub-class Species in the Iris dataset. This example uses base R’s split() to return a list of dataframes by group: split(iris, iris$Species) %&gt;% map(~ lm(Sepal.Length ~ Sepal.Width, data = .x)) %&gt;% map(~ coef(.x)) %&gt;% map_dbl(&#39;Sepal.Width&#39;) ## setosa versicolor virginica ## 0.6904897 0.8650777 0.9015345 In Base R using functionals: temp_var &lt;- split(iris, iris$Species) temp_var &lt;- lapply(temp_var, function(x) lm(Sepal.Length ~ Sepal.Width, data = x)) vapply(temp_var, function(x) coef(x)[[&#39;Sepal.Width&#39;]], FUN.VALUE = double(1)) ## setosa versicolor virginica ## 0.6904897 0.8650777 0.9015345 1.1.8.3 Map variants The map() family of functions has orthagonal inputs and outputs, meaning they can be summarised in a 2d matrix[input, output]: (input) List Atomic Vector Same type Nothing One Argument map() map_lgl(), ... modify() walk() Two Arguments map2() map2_lgl(), ... modify2() walk2() One Argument + index imap() imap_lgl(), ... imodify() iwalk() n Arguments pmap() pmap_lgl(), ... pwalk() 1.1.8.3.1 modify() modify() always returns the same vector type as the input: # Logical input = logical output modify(c(T,F,T), ~ is.numeric(.x)) ## [1] FALSE FALSE FALSE # Dataframe input = dataframe output modify(data.frame(a=1:10, b=10:1), ~ .x *100) ## a b ## 1 100 1000 ## 2 200 900 ## 3 300 800 ## 4 400 700 ## 5 500 600 ## 6 600 500 ## 7 700 400 ## 8 800 300 ## 9 900 200 ## 10 1000 100 1.1.8.3.2 map2() map2() is vectorized over two arguments before the function: map2_chr(1:3, letters[1:3], ~ paste0(.x, .y)) ## [1] &quot;1a&quot; &quot;2b&quot; &quot;3c&quot; 1.1.8.3.3 walk() walk() returns a NULL list and is said to return “nothing”. You would use this when you want to map a function over arguments for their side-effects, e.g. saving plots, writing data, printing messages: iwalk(c(&#39;Tom&#39;,&#39;Jerry&#39;), ~ message(&#39;Hi-ya, &#39;, .x ,&#39;!&#39;)) ## Hi-ya, Tom! ## Hi-ya, Jerry! 1.1.8.3.4 imap() imap() allows you to iterate on a vector and its index in parallel. It’s similar to map2(.x, .y = names(.x)) if .x is named, or map2(.x, .y = seq_along(.x)) if not. This is useful for labeling vectors already named, or working with vector elements and their index position (e.g. accessing further variables at the same index location). iwalk(split(iris, iris$Species)[1:2], ~ plot(.x$Sepal.Width, .x$Sepal.Length, main = paste0(.y))) 1.1.8.3.5 pmap() pmap() generalizes the number of input vectors to decompose by passing a (possibly named) list for .l, commonly, a dataframe. pmap_dbl(.l = data.frame(a = 1:3, b=1:3, c=1:3), ~ .x + .y + ..3) ## [1] 3 6 9 In base R you can use Map() or mapply() for similar functionality. Map() is a wrapper for mapply() that will not try to simplify the return vector like mapply() will. Map() decomposes all input vectors. Map(function(...) ..1 + ..2 + ..3, 1:3, 1:3, 1:3) %&gt;% str() ## List of 3 ## $ : int 3 ## $ : int 6 ## $ : int 9 mapply(function(...) ..1 + ..2 + ..3, 1:3, 1:3, 1:3) ## [1] 3 6 9 1.1.8.4 Reduce The next important family of functionals is reduce() and is related to the map-reduce framework that powers many “big data” stacks. reduce() reduces a list to a single vector. 1.1.8.4.1 Basics In essence, reduce() (or Reduce() in base R) applys a binary function to two elements of a vector, and reduces the result to the first argument of the next function call plus the next element. For example, a four element vector: f( f( f(1,2), 3), 4) Or, to restate, reduce() reduces a list to a single vector. # Generate a 3 element list with 10 bootstrap samples from `1:20` set.seed(11) v &lt;- map(1:3, ~ sample(x = 1:20, size = 10, replace = TRUE)) str(v) ## List of 3 ## $ : int [1:10] 2 16 17 5 12 7 3 11 7 13 ## $ : int [1:10] 2 17 8 15 7 6 14 3 3 11 ## $ : int [1:10] 18 12 2 3 10 16 11 2 9 8 In this example, we want to return a set containing numbers that appear in every element vector. reduce() applies intersect( intersect(v[[1]], v[[2]]), v[[3]]) to find 2, 3, and 11 appear in each. reduce(v, intersect) ## [1] 2 3 11 Or, if we wanted to return the vector element with the greatest sum: reduce(v, function(x, y) if (sum(x) &gt;= sum(y)) x else y ) ## [1] 2 16 17 5 12 7 3 11 7 13 # check this is correct by applying sum over each element # reduce returned the first vector, which had the largest sum: 93 map_dbl(v, sum) ## [1] 93 86 91 1.1.8.4.2 Accumulate accumulate() (or base R Accumulate()) is a reduce() variant that also returns all intermediate results, rather than just the final: # reduce only returns the final result reduce(1:10, sum) ## [1] 55 # accumulate returns all call results; in this case the cummulative sum accumulate(1:10, sum) ## [1] 1 3 6 10 15 21 28 36 45 55 # our example from earlier intersecting each element of v show how the set # reduced with each call accumulate(v, intersect) %&gt;% str() ## List of 3 ## $ : int [1:10] 2 16 17 5 12 7 3 11 7 13 ## $ : int [1:5] 2 17 7 3 11 ## $ : int [1:3] 2 3 11 1.1.8.4.3 Output types reduce() has an important argument .init. If supplied, .init is used to start the accumulation. For example, what if you created a function using reduce(), except it’s later passed a zero length vector? reduce(double(), sum) ## Error: `.x` is empty, and no `.init` supplied You can supply an initial value instead: reduce(double(), sum, .init = 0) ## [1] 0 1.1.8.4.4 Multiple inputs reduce2() exists, which takes two lists to decompose. The length of .y may vary if you supply .init. This is a very rare scenario, but the functionality exists when you need it. 1.1.8.4.5 Map-Reduce The concept of map-reduce is used to power “big data” applications like Hadoop. Put simply, vectors are mapped over multiple computers and then sent back to the conductor, which reduces the results into an output vector. 1.1.8.5 Predicates Predicates are functions that return a single TRUE/FALSE like is.null() or all(). If the predicate returns TRUE you say the predicate matches the vector. 1.1.8.5.1 Predicate functionals Predicate functionals apply a predicate to each element of a vector. Purrr has the following variant pairs: some() if any element matches (base R any()) every() if all elements match (base R all()) df &lt;- data.frame(a = 1:4, b = letters[1:4], c = 4:1, d = letters[4:1], stringsAsFactors = F) some(df, .p = is.numeric) ## [1] TRUE every(df, .p = is.numeric) ## [1] FALSE detect() return the value of the first match detect_index return the location of the first match detect(df, .f = is.character) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; detect_index(df, .f = is.character) ## [1] 2 keep() keep all matching elements discard() discard all matching elements keep(df, .p = is.numeric) ## a c ## 1 1 4 ## 2 2 3 ## 3 3 2 ## 4 4 1 discard(df, .p = is.numeric) ## b d ## 1 a d ## 2 b c ## 3 c b ## 4 d a 1.1.8.5.2 Map variants map() and modify() contain predicate variants that only apply over elements that match a predicate: df %&gt;% str() ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ a: int 1 2 3 4 ## $ b: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## $ c: int 4 3 2 1 ## $ d: chr &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot; map_if(df, .p = is.numeric, ~ .x*2) %&gt;% str() ## List of 4 ## $ a: num [1:4] 2 4 6 8 ## $ b: chr [1:4] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## $ c: num [1:4] 8 6 4 2 ## $ d: chr [1:4] &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot; modify_if(df, .p = is.character, ~ toupper(.x)) %&gt;% str() ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ a: int 1 2 3 4 ## $ b: chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ## $ c: int 4 3 2 1 ## $ d: chr &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; # wrap .x in a predicate functional to discard() or keep() columns by predicate map_dbl(discard(df, is.character), ~ sum(.x)) ## a c ## 10 10 1.1.8.6 Base functionals There are many more functionals in base R with mathmatrics/statistical applications, such as integrate() to find the area under the curve of a function, uniroot() to find where a function hits zero, and optimise() to return the highest and lowest values of a function. Read more in Base Functionals. Portable Operating System Interface standard.↩︎ "],
["misc-temp-r.html", "1.2 Misc Temp R", " 1.2 Misc Temp R 1.2.1 combining execution { curly braces can be used to execute multiple expressions; and only returns the last expression. It does not create a new environment outside of functions. Separate statements with ; or newline: { x &lt;- 1 y &lt;- 2 x+y } ## [1] 3 { set.seed(7); rnorm(1) } ## [1] 2.287247 1.2.2 Infix functions Operator Type Description Note Rank :: Extract Retrieve Function Extract function from package namespace; e.g. package::function() 1 ::: Extract Retrieve Function Extract hidden function from namespace 1 $ Extract List Subset Extract list element by name; see name() 2 @ Extract Slot selecton Extract attributes by memory slot; see slotnames() 2 [ Extract Subscripting Extract potentially multiple elements by index/dim vector; lists return lists 3 [[ Extract Subscripting Extract single elements by index or name; lists return the object 3 ^ Arithmetic Exponential 2^3 = 8 4 : Sequence Sequence 1:3 = 1, 2, 3; 1:-1 = 1, 0, -1 5 %/% Arithmetic Integer Divide 5 %/% 2 = 2; divide, then drop fractions 6 %% Arithmetic Modulo 7 %% 5 = 2; remainder after divison 6 %*% Arithmetic Matrix Multiplication Multiplies two conformable matricies 6 %o% Arithmetic Outer Product gives the outer product of arrays 6 %x% Arithmetic Kronecker product Kronecker product of two arrays 6 * Arithmetic Multiplication Also matrix dot product 7 / Arithmetic Division 7 + Arithmetic Addition 8 - Arithmetic Subtraction 8 ! Comparison Not 8 %in% Comparison Match Values 1 %in% 1:3 = TRUE 9 != Comparison Not equal to 1 != 2 = TRUE 9 &lt; Comparison Less than 1 &lt; 2 = TRUE 9 &gt; Comparison Greater than 1 &gt; 3 = FALSE 9 == Comparison Equal to 2 == 2 = TRUE 9 &lt;= Comparison Less than or Equal to 1 &lt;= 1 = TRUE 9 &gt;= Comparison Greater than or Equal to 2 &gt;= 2 = TRUE 9 xor Logical Exclusive or element-wise if either, but not both, are TRUE: xor(1:2==1, 1:2&lt;3) = FALSE, TRUE 10 &amp; Logical And (element) element-wise logical AND &amp;&amp; Logical And (control) checks only first elements are logical AND; returns scalar 10 | Logical Or (element) element-wise logical OR 10 || Logical Or (control) checks only first elements are logical OR; returns scalar 10 ~ Assignment Equal Used for assignment in formulas 11 &lt;&lt;- Assignment Permanent Assignment Mainly used in closures to maintain state 12 &lt;- Assignment Left Assignment 13 -&gt; Assignment Right Assignment 13 = Assignment Argument Assignment 13 "],
["import.html", "2 Import", " 2 Import "],
["tidy.html", "3 Tidy", " 3 Tidy "],
["transform.html", "4 Transform", " 4 Transform "],
["visualise.html", "5 Visualise", " 5 Visualise "],
["statistics.html", "6 Statistics", " 6 Statistics "],
["set-theory.html", "6.1 set theory", " 6.1 set theory "],
["communicate.html", "7 Communicate", " 7 Communicate "],
["markdownbookdown-tips.html", "7.1 Markdown/bookdown tips", " 7.1 Markdown/bookdown tips 7.1.1 Syntax 7.1.1.1 Inline Formatting Element Code Notes Italic *Italic* or _Italic_ single asterisks or underscores Bold **Bold** or _Bold_ double asterisks or underscores Bold Italic ***Bold Italic*** triple asterisks or underscores Underline __Underline__ two underscores Strike-through ~~Strike-through~~ double tildes Subscript Sub~script~ single tildes Superscript Super^script^ single carets \\(\\LaTeX\\) $\\LaTeX$ enclose syntax with $ inline_code() `inline_code()` single back-ticks R, Inline, Code `r c('R','Inline','Code')` single back-ticks beginning r space Hyperlink [Hyperlink](https://www.google.com) [text](link) ![R Logo](./Rlogo.png) ![text](link) Footnote3 ^[Example footnote.] requires a . Citation (2020) @example @tag ref to BibTeX citation (Citation 2020) [@example] alternative style 7.1.1.2 Line Returns To force a line return use two spaces instead of one. 7.1.1.3 Section Headers # level 1 header ## level 2 header ### level 3 header etc... Add {-} after the header to remove section numbering: # Preface {-} 7.1.1.4 Unordered Lists item 1 item 2 sub-item 1 Unordered list items start with *, -, or +; and can be nested by indenting the next item by four spaces: * item 1 * item 2 * sub-item 1 7.1.1.5 Ordered lists item 1 item 2 sub-item 1 Ordered lists begin with a number and a period. Same indenting rules as unordered lists: 1. item 1 2. item 2 1. sub-item 1 7.1.1.6 Block Quotes \"You miss 100% of the shots you don’t take. — Wayne Gretzky\" — Michael Scott Block quotes begin with a &gt;. You can use markdown formatting or HTML tags to right align the author: &gt; &quot;You miss 100% of the shots you don&#39;t take. &gt; &gt; --- Wayne Gretzky&quot; &gt; &gt; &lt;div style=&quot;text-align: right&quot;&gt; --- Michael Scott&lt;/div&gt; 7.1.1.7 Code Blocks ``` Use three back ticks to display a block of text without markdown formatting. ``` 7.1.1.7.1 Syntax highlighting Include the language name after the initial backticks: ```r data.frame(x = 1:10) ``` renders as : data.frame(x = 1:10) 7.1.1.8 Tables 7.1.1.8.1 Grid Tables Basic tables can be used by aligning +,-, &amp; | in a grid as below. One advantage is the ability to put more than one markdown element in a cell. No alignment options are available and you may have to reformat your table manually. +------------+--------+--------+ |Date |Event | Times| +------------+--------+--------+ |30-Apr-2020 |Swimming|* 3:00pm| | | |* 4:30pm| +------------+--------+--------+ Date Event Times 30-Apr-2020 Swimming 3:00pm 4:30pm 7.1.1.8.2 Pipe Tables Pipe tables are more flexible on formatting and allow alignment. Space must be left before and after the table, but pipes do not have to align. The dashes indicate the header and colon for aligning the text. Show *(left)* | Character *(center)* | Color *(right)* :--- | :---: | ---: Paw Patrol | Rocky | Green Paw PatrolRubble | Yellow Paw Patrol | Chase | Blue Paw Patrol | Marshall | Red Paw Patrol | Zuma | Orange Paw Patrol | Sky | Pink returns: Show Character Color Paw Patrol Rocky Green Paw Patrol Rubble Yellow Paw Patrol Chase Blue Paw Patrol Marshall Red Paw Patrol Zuma Orange Paw Patrol Sky Pink 7.1.1.9 Horizontal Rules Three or more ***, ---, or ___ will produce a horizontal rule; as will the &lt;hr&gt; HTML tag. 7.1.1.10 Task lists For checked and unchecked tasklist items you can write an unordered list with [ ] or [x]. Notice the space between and surrounding brackets with text following. - [ ] Garbage - [x] Dishes Garbage Dishes 7.1.2 Cache large code chunks ```{r chunk-id, cache=TRUE} 7.1.3 Chunk Options 7.1.3.1 Collapse collapse=TRUE results in x &lt;- 1:10; print(x) ## [1] 1 2 3 4 5 6 7 8 9 10 rather than x &lt;- 1:10; print(x) ## [1] 1 2 3 4 5 6 7 8 9 10 7.1.3.2 Error error=TRUE 7.1.4 Resources Bookdown: Authoring Books with R Markdown by its creator, Yihui Xie. Pandoc Citation. 2020. “BibTeX Citation Example.” Example footnote.↩︎ "]
]
