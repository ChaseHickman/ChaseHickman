[
["index.html", "Preface", " Preface docendo discimus (by teaching we learn) —Seneca the Younger (c. 4 BC – 65 AD) This is a personal repository for digesting concepts and practicing critical storytelling related to analyzing data, mainly using the R Project for Statistical Computing. "],
["introduction.html", "Introduction", " Introduction I intend to follow a project-oriented workflow for organizing this information: Programming Import Tidy Transform Visualise Statistics Communicate "],
["licensing.html", "Licensing", " Licensing I am publishing this book with no license, which means: When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. "],
["about-the-author.html", "About the Author", " About the Author I am the lead Data Analytics Consultant in HR for the University of Missouri System. I earned my BFA summa cum laude from the University of Missouri in 2009, with a minor in Art History; and have been employed by the University since 2009. "],
["programming.html", "Programming", " Programming "],
["advanced-r.html", "Advanced R", " Advanced R Advanced R 2nd ed. Hadley Wickham 0.0.1 Names and Values Binding In R, names are assigned a value (e.g. a vector doesn’t have a name, rather, a name(s) points to a vector). The actual address of an object is exposed by lobstr::obj_addr(). x &lt;- 1:10 obj_addr(x) ## [1] &quot;0x16b0fd08&quot; # notice x and y are pointers to the same object y &lt;- x obj_addr(y) ## [1] &quot;0x16b0fd08&quot; # this applies to function arguments in their environment as well fn &lt;- function(z){ z } # fn() returns the argument z at the same address obj_addr(fn(x)) ## [1] &quot;0x16b0fd08&quot; Syntactic Names Names in R can be letters, numbers, . or _; but cannot start with a number or _ or contain ?Reserved words. # assigning a vector a name startign with `_` throws an error _x &lt;- 1:10 ## Error: &lt;text&gt;:2:1: unexpected input ## 1: # assigning a vector a name startign with `_` throws an error ## 2: _ ## ^ Copy-on-Modify R objects are generally immutable. A new copy is made when you modify an object. There are two Modify-in-Place exceptions. # create vector x x &lt;- 1:10 obj_addr(x) ## [1] &quot;0x18feee48&quot; # modify first value in x x[[1]] &lt;- 0 # note x now points to a new object obj_addr(x) ## [1] &quot;0x1905cd10&quot; Trace Copying of Objects base::tracemem() will mark an object and print a message whenever it is copied. This is a major cause of hard-to-predict memory usage. # tell R to trace copies of object reference `x` tracemem(x = x) # modify the first element in vector `x` # R prints a tracemem message to show the object is copied to a new address x[[1]] &lt;- 2 #&gt; tracemem[0x000002379ca5a190 -&gt; 0x000002379cd8dbb0]: # tell R to stop tracing this object base::untracemem(x = x) List Objects Just like variables, each element of a list also points to a value. Copy-on-modify and modify-in-place applies here as well. R creates a shallow copy of the list. Meaning the list object and its bindings are copied; however, the underlying values are not. In a deep copy, like prior to R 3.1.0, the underlying values are also copied. # create a list named `l` l &lt;- list(1:10, TRUE, c(&#39;Apple&#39;,&#39;Broccoli&#39;,&#39;Chowder&#39;)) # show the address of the third list element obj_addr(l[[3]]) ## [1] &quot;0x1955d5c0&quot; # modify the third list element l[[3]] &lt;- c(&#39;Appricot&#39;,&#39;Basmati Rice&#39;,&#39;Cheese&#39;) # the third list element&#39;s address is changed obj_addr(l[[3]]) ## [1] &quot;0x196259f0&quot; Use lobstr::ref() to see common values between lists: # create a list object listA &lt;- list(1,2,3) # create a new pointer to the same list object listB &lt;- listA # modify the third list element of listB, creating a shallow copy of the list object listB[[3]] &lt;- 4 # ref() lists the address of each list element. Notice two values are still shared # between `listA` and `listB`. ref(listA, listB) ## o [1:0x1997dab0] &lt;list&gt; ## +-[2:0x19812988] &lt;dbl&gt; ## +-[3:0x19812950] &lt;dbl&gt; ## \\-[4:0x19812918] &lt;dbl&gt; ## ## o [5:0x199f43b0] &lt;list&gt; ## +-[2:0x19812988] ## +-[3:0x19812950] ## \\-[6:0x19830b20] &lt;dbl&gt; Data Frames A data frame is simply a list where each element is a vector of the same length. # create a data frame with three columns df &lt;- data.frame(col1 = TRUE, col2 = 1:10, col3 = rep(x = c(&#39;On&#39;,&#39;Off&#39;), length.out = 10)) # show the address of the data frame and each element (i.e. column) ref(df) ## o [1:0x1ac64988] &lt;df[,3]&gt; ## +-col1 = [2:0x1ac487b0] &lt;lgl&gt; ## +-col2 = [3:0x1ac40cd0] &lt;int&gt; ## \\-col3 = [4:0x1ac48900] &lt;fct&gt; When a column is modified only one element is copied: # modify a column and note the addresses of the unchanged columns remain the same # because they point to the same objects as before df$col1 &lt;- FALSE; ref(df) ## o [1:0x1afa49e0] &lt;df[,3]&gt; ## +-col1 = [2:0x1af8fe80] &lt;lgl&gt; ## +-col2 = [3:0x1ac40cd0] &lt;int&gt; ## \\-col3 = [4:0x1ac48900] &lt;fct&gt; This has important consequences for memory when you update rows of data where each element gets copied: # modify the first row of the data frame df[1,] &lt;- c(TRUE, 0, &#39;Off&#39;) # *all* elements are copied to new addresses ref(df) ## o [1:0x1b3a8ef0] &lt;df[,3]&gt; ## +-col1 = [2:0x1b3a0d30] &lt;chr&gt; ## +-col2 = [3:0x1b3b2b40] &lt;chr&gt; ## \\-col3 = [4:0x1b3a4fe0] &lt;fct&gt; Character Vectors R uses a global string pool to store unique character objects so they are not duplicated unnecessarily. Use the character argument to show their address in the global string pool with lobstr::ref(): # create a character vector chr &lt;- c(&#39;Quarter&#39;, &#39;Dime&#39;, &#39;Nickle&#39;, &#39;Penny&#39;, &#39;Penny&#39;) # show addresses in the global string pool. Notice the shared value for &#39;Penny&#39; ref(chr, character = TRUE) ## o [1:0x14306490] &lt;chr&gt; ## +-[2:0x15513a70] &lt;string: &quot;Quarter&quot;&gt; ## +-[3:0x15513ae0] &lt;string: &quot;Dime&quot;&gt; ## +-[4:0x15513b88] &lt;string: &quot;Nickle&quot;&gt; ## +-[5:0x15513bf8] &lt;string: &quot;Penny&quot;&gt; ## \\-[5:0x15513bf8] Object Size lobstr::obj_size() shows the amount of memory an object takes, while obj_sizes() breaks down multiple objects into their individual contribution to total memory. Due to binding names, global string pools, and ALTREP (alternate representation where some vectors are stored in a compact manor; e.g. 1:1000 only stores the first and last numbers, not 1,000 numbers) the size of objects may surprise you. # create a length one chracter vector and a length 100 character vector x &lt;- &#39;Charlie&#39; y &lt;- rep(x = &#39;Charlie&#39;, times = 100) # y is only ~8x the size of x, not 100x obj_size(x); obj_size(y) ## 112 B ## 904 B z &lt;- 1:10 # create a list with one element `z` list1 &lt;- list(z) # create a list with three elements, all `z` list2 &lt;- list(z, z, z) # list2 only contributes an extra 80 Bytes to the total memory between the two obj_sizes(list1, list2) ## * 736 B ## * 80 B Modify-in-Place There are two places where R will optimize memory by modfiying an object “in place” (i.e. does not make a copy). objects with a single binding &gt; hats &lt;- c(&#39;red&#39;,&#39;brown&#39;,&#39;blue&#39;) &gt; obj_addr(hats) [1] &quot;0x1d51fe614d8&quot; &gt; &gt; hats[[1]] &lt;- &#39;orange&#39; &gt; obj_addr(hats) [1] &quot;0x1d51fe614d8&quot; # note this is output from the R Console. RStudio runs everything within an Environment # which breaks modify-in-place behavior This is one reason why looping in R is inefficient, the user is unwittingly copying objects many times over: # create a dataframe df &lt;- data.frame(col1 = c(1:3)) # trace copies of this dataframe tracemem(df) ## [1] &quot;&lt;00000000196335A8&gt;&quot; # use a for loop to increment the dataframe values # R copies the object 12 times!!! for (i in 1:3){ df[[1]][i] &lt;- df[[1]][i] + 1 } ## tracemem[0x00000000196335a8 -&gt; 0x0000000019892be8]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000019892be8 -&gt; 0x0000000019892a28]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x0000000019892a28 -&gt; 0x00000000198a4e18]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a4e18 -&gt; 0x00000000198a4c90]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a4c90 -&gt; 0x00000000198a4b08]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a4b08 -&gt; 0x00000000198a49b8]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a49b8 -&gt; 0x00000000198a48d8]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a48d8 -&gt; 0x00000000198a4750]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a4750 -&gt; 0x00000000198a45c8]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a45c8 -&gt; 0x00000000198a4478]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a4478 -&gt; 0x00000000198a4398]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local ## tracemem[0x00000000198a4398 -&gt; 0x00000000198a4210]: [[&lt;-.data.frame [[&lt;- eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local # turn of object memory trace untracemem(df) Environments Environments are always modified in place and all objects within the environment keep the same reference. Unbinding and Garbage Collector (GC) The (GC) garbage collector deletes objects that are no longer used and requests more memory from the operating system as needed to create objects. For example: # create three objects all bound to `x` x &lt;- 1:10 x &lt;- c(&#39;one&#39;,&#39;two&#39;,&#39;three&#39;) x &lt;- TRUE # removing `x` causes GC to delete the three objects b/c they have no other bindings remove(x) You can call GC yourself with base::gc(), but the user should not ever have the need. Session Info ## R version 3.6.1 (2019-07-05) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18363) ## ## Matrix products: default ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] lobstr_1.1.1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.1 bookdown_0.16 digest_0.6.20 crayon_1.3.4 ## [5] magrittr_1.5 evaluate_0.14 pillar_1.4.2 rlang_0.4.5 ## [9] stringi_1.4.3 vctrs_0.2.4 rmarkdown_1.13 tools_3.6.1 ## [13] stringr_1.4.0 xfun_0.8 yaml_2.2.0 compiler_3.6.1 ## [17] htmltools_0.4.0 knitr_1.23 0.0.2 Vectors R has two types of vectors: atomic vectors and list vectors. Atomic vectors have values all of the same type, while lists can have values of different types. NULL is not a vector, but is often used in R to represent a zero length vector. For practical purposes you can consider it a vector. Vectors can have attributes; the most important are dimension and class. dimension: turns a vector into matrices and arrays class: critical for S3 objects like factors, dates &amp; date-time, data frames, and tibbles Atomic Vectors Types There are four primary types of atomic vectors, and their scalars (i.e. individual value) can be instantiated as: Logical: TRUE/T;FALSE/F Double: decimal 2.345, scientific 2e10, hexadecimal 3425h, infinite Inf/-Inf, Not a Number NaN Integer: a non-fractional double followed by L (e.g. 7L, 2e7L, 3425hL ) Character: strings surrounded by single/double quotes; 'Cats' or \"Dogs\" Doubles and Integers belong to meta-type numeric. is.numeric() tests if a vector can be interpreted as a number: is.numeric(2.2) = TRUE = is.numeric(2L) = TRUE Combine scalars Scalars can be combined to make longer vectors using c(): c(1,2,3) ## [1] 1 2 3 c(T,T,F) ## [1] TRUE TRUE FALSE R will flatten atomic vectors when combined with other atomic vectors: c(1,c(2,c(2.1,2.2,2.3)),4) ## [1] 1.0 2.0 2.1 2.2 2.3 4.0 typeof() and length() will return the type and length of an atomic vector: x &lt;- TRUE; y &lt;- c(1L, 2L, 3L, 4L) typeof(x); length(x) ## [1] &quot;logical&quot; ## [1] 1 typeof(y); length(y) ## [1] &quot;integer&quot; ## [1] 4 typeof(NULL); length(NULL) ## [1] &quot;NULL&quot; ## [1] 0 Missing values Missing values are represented by NA (Not Applicable). There are logical (NA), integer (NA_integer_), double (NA_real_), and character (NA_character_) types but R will parse the appropriate NA needed. Many logistical tests in R containing NA will return NA: # not false returns true; not NA returns NA !FALSE; !NA ## [1] TRUE ## [1] NA For this reason, finding missing values in a vector is not obvious: x &lt;- c(0,NA,NA,3,4) # a logistical test for NA returns all NA x==NA ## [1] NA NA NA NA NA Instead, use is.na() to test for missing values: is.na(x) ## [1] FALSE TRUE TRUE FALSE FALSE The exception is when all possible values would not change the result: # this logical statement is true regardless of all possible NA values NA | TRUE ## [1] TRUE Testing and coercing vectors There are many is.*() pattern functions in R to test vector type. is.logical(), is.integer(), is.double(), and is.character() all test for the four primary atomic vector types: is.logical(x = c(T,T,F,F)) ## [1] TRUE is.integer(x = c(2.2, 3.0)) ## [1] FALSE However, some is.*() pattern functions behave unexpectedly. is.numeric(), for example, returns false for factors, Date, POSIXt and difftime because they have their own methods for detection; even though they are numbers and arithmetic generally makes sense. So be sure to read the documentation carefully (?is.numeric()). coercing types It is possible to coerce vectors to a new type, or two combine two types of vectors into one. The types will be coerced in this order: character &gt; double &gt; integer &gt; logical Use as.*() functions to specifically coerce types. R can also implicitly coerce types when needed. R will give a warning message if it fails or NAs are introduced. # combining a double and a character returns a character vector str(c(1,&quot;2&quot;)) ## chr [1:2] &quot;1&quot; &quot;2&quot; # implicitly return the sum of a logical as integer str(sum(c(T,T,F))) ## int 2 # explicitly coerce doubles to characters str(as.character(c(2e1, 200))) ## chr [1:2] &quot;20&quot; &quot;200&quot; Attributes Other data-structures in R are built on top of these atomic vectors using attributes. For example, the dimension attribute transforms vectors into matrices and arrays. Getting and setting attributes Attributes are like meta-data you assign in name-value pairs: attr() to retrieve and set single attributes attributes() to retrieve multiple attributes structure() to set multiple attributes fruit &lt;- 1:10 # create fruit attributes type and days old attr(x = fruit, which = &#39;type&#39;) &lt;- c(&#39;orange&#39;,&#39;apple&#39;,&#39;pear&#39;) attr(fruit,&#39;type&#39;) ## [1] &quot;orange&quot; &quot;apple&quot; &quot;pear&quot; attr(x = fruit, which = &#39;days old&#39;) &lt;- 2 str(attributes(x = fruit)) ## List of 2 ## $ type : chr [1:3] &quot;orange&quot; &quot;apple&quot; &quot;pear&quot; ## $ days old: num 2 # simultaneously create object and attributes fruit &lt;- structure( 1:10, type = c(&#39;orange&#39;,&#39;apple&#39;,&#39;pear&#39;), &#39;days old&#39; = 2 ) str(attributes(fruit)) ## List of 2 ## $ type : chr [1:3] &quot;orange&quot; &quot;apple&quot; &quot;pear&quot; ## $ days old: num 2 Names names is a special and important attribute in R. Although it is not enforced, names should be unique and complete. They can be set several ways: # on creation x &lt;- c(a=1,b=2,c=3) attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # assigning a vector of names x &lt;- 1:3 names(x) &lt;- letters[1:3] attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # inline with setNames() x &lt;- setNames(1:3, letters[1:3]) attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # with attr() attr(x, which = &#39;names&#39;) &lt;- letters[1:3] attr(x, which=&#39;names&#39;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Dimensions The dim attribute transforms NULL dimensional vectors into 2d matrices and multi-dimensional arrays, and can be set by dim(), matrix(), and array(): x &lt;- 1:6 dim(x) &lt;- c(2,3) x ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix(data = 1:6, nrow = 1, ncol = 6) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 array(data = 1:6, dim = c(2,3)) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # non-idiomatic attr(x, &#39;dim&#39;) &lt;- c(3,2) x ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Vector functions usually have matrix or array counterparts: # vector, matrix, and array bindings v &lt;- structure(.Data = 1:9, names = letters[1:9]) m &lt;- matrix(data = 1:9, nrow = 3, ncol = 3, dimnames = list(letters[1:3], letters[1:3])) a &lt;- array(data = 1:9, dim = c(3,3), dimnames = list(letters[1:3], letters[1:3])) # Names names(v) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; rownames(m); colnames(m) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; dimnames(a) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # Lengths length(v) ## [1] 9 nrow(m);ncol(m) ## [1] 3 ## [1] 3 dim(a) ## [1] 3 3 # Combine c(v, c(j=10)) ## a b c d e f g h i j ## 1 2 3 4 5 6 7 8 9 10 rbind(m, 10:12);cbind(m, 10:12) ## a b c ## a 1 4 7 ## b 2 5 8 ## c 3 6 9 ## 10 11 12 ## a b c ## a 1 4 7 10 ## b 2 5 8 11 ## c 3 6 9 12 abind::abind(a, 10:12, along=1); abind::abind(a, 10:12, along=2) ## a b c ## a 1 4 7 ## b 2 5 8 ## c 3 6 9 ## 10 11 12 ## a b c ## a 1 4 7 10 ## b 2 5 8 11 ## c 3 6 9 12 # Transpose t(m) ## a b c ## a 1 2 3 ## b 4 5 6 ## c 7 8 9 aperm(a) ## a b c ## a 1 2 3 ## b 4 5 6 ## c 7 8 9 # Type test is.vector(v, mode=&#39;any&#39;) ## [1] TRUE is.matrix(m) ## [1] TRUE is.array(a) ## [1] TRUE Vectors may have different dimensions. They may print similar but will behave differently. Pay attention to [] syntax: # 1d vector str(1:10) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 # column vector str(matrix(1:10, ncol = 1)) ## int [1:10, 1] 1 2 3 4 5 6 7 8 9 10 # row vector str(matrix(1:10, nrow = 1)) ## int [1, 1:10] 1 2 3 4 5 6 7 8 9 10 # 1d &quot;array&quot; vector str(array(1:10, 10)) ## int [1:10(1d)] 1 2 3 4 5 6 7 8 9 10 S3 Atomic Vectors The attribute class is what makes an object part of the S3 object system in R, and changes how generic functions behave compared to regular vectors. S3 objects are built on top of atomic vectors. Factors Factors are a ubiquitous S3 object in base R. They handle categorical variables where the vector must contain only known values. Factors are built on atomic vectors of type integer, and only have two attributes: class “factor” and levels, which defines the set, and sometimes order, of possible values. Use factor() create a factor: x: a vector coercible to character levels: a unique vector of expected values in x; which can contain values not found in x or, conversly, exclude values found in x labels: a vector of name aliases for levels (in the same order as levels) or scalar # create a factor from a vector of state abbreviations # tell R to expect values MO, NY, AK, HI and their aliases are Missouri, New York, Alaska, # &amp; Hawaii states &lt;- factor(x = c(&#39;MO&#39;,&#39;NY&#39;,&#39;AK&#39;,&#39;MO&#39;,&#39;AK&#39;,&#39;IL&#39;), levels = c(&#39;MO&#39;,&#39;NY&#39;,&#39;AK&#39;,&#39;HI&#39;), labels = c(&#39;Missouri&#39;,&#39;New York&#39;,&#39;Alaska&#39;,&#39;Hawaii&#39;)) # factor() converts the vector to integer values under-the-hood. These are rarely visible # but can be exposed using c() (or unclass() but then you no longer have a factor). The # integer refers to the sequence of levels given, starting with &#39;MO&#39; in this case. str(c(states)) ## int [1:6] 1 2 3 1 3 NA # usually factors print their levels attribute states ## [1] Missouri New York Alaska Missouri Alaska &lt;NA&gt; ## Levels: Missouri New York Alaska Hawaii # notice it did not print the levels given in factor(), but rather the label aliases # were given to attribute `levels`. If no labels argument is given it defaults to same # as levels. attributes(states) ## $levels ## [1] &quot;Missouri&quot; &quot;New York&quot; &quot;Alaska&quot; &quot;Hawaii&quot; ## ## $class ## [1] &quot;factor&quot; # if no levels argument was given, factor() would have defaulted to the unique set of values # in x in ascending order. Note this would include Illinois (which we originally excluded and # values in states became `NA`), and would have excluded Hawaii (which we may have wanted # even though it is not in the current vector x). sort(unique(as.character(c(&#39;MO&#39;,&#39;NY&#39;,&#39;AK&#39;,&#39;MO&#39;,&#39;AK&#39;,&#39;IL&#39;)))) ## [1] &quot;AK&quot; &quot;IL&quot; &quot;MO&quot; &quot;NY&quot; # notice tabulated results appear in level order and include counts even for values not # present in states table(states) ## states ## Missouri New York Alaska Hawaii ## 2 1 2 0 # many base R functions convert character vectors to factor by default. This may not be # desirable as the vector may not contain the complete set of values, or infer their # correct order. class(data.frame(x=c(&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;))[[1]]) ## [1] &quot;factor&quot; # use arguement stringsAsFactor to inhibit default factor creation class(data.frame(x=c(&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;), stringsAsFactors = FALSE)[[1]]) ## [1] &quot;character&quot; Some categorical variables have order. Methods and modeling functions usually treat ordered and unordered factors very differently. Use ordered() to create an object of class “ordered factor”, where the order in levels implies the order between factor levels. priority &lt;- ordered(x = c(&#39;low&#39;,&#39;medium&#39;,&#39;high&#39;), levels = c(&#39;low&#39;,&#39;medium&#39;,&#39;high&#39;)) str(priority) ## Ord.factor w/ 3 levels &quot;low&quot;&lt;&quot;medium&quot;&lt;..: 1 2 3 Finally, some functions coerce factors into strings (e.g. grepl()) while others (e.g. c()) return the integer substrate. If you want string-like behavior, best to coerce as.character() before performing string operations. Dates Date vectors are S3 objects built on type double, and have only attribute: class “Date”. They represent days from the UNIX Epoch, 01-Jan-1970; and take into account leap-days, but not leap-seconds. # today&#39;s date today &lt;- Sys.Date() typeof(today) ## [1] &quot;double&quot; class(today) ## [1] &quot;Date&quot; # unclass the Date object to see the underlying double unclass(today) ## [1] 18382 Date-times S3 Date-times come in two flavors: POSIX1ct (calendar time) &amp; POSIXlt (local time). POSIXct is build on type double whereas POSIXlt is type list, which we’ll discuss later. POSIXct represents the number of seconds since the UNIX Epoch, 01-JAN-1970, and has the attributes class &amp; tzone. Pass the tz argument a tz database time zone to change attribute tzone from the default local time. This does not change the underlying double, only how it prints. ct &lt;- as.POSIXct(x = &quot;2020-04-28 05:00:00&quot;, tz=&#39;UTC&#39;) # the calendar time object ct ## [1] &quot;2020-04-28 05:00:00 UTC&quot; # built on doubles typeof(ct) ## [1] &quot;double&quot; # has attributes class and tzone attributes(ct) ## $class ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; ## ## $tzone ## [1] &quot;UTC&quot; # change tzone attribute to EDT, CDT, JST; notice midnight does not print a time attr(ct, which = &#39;tzone&#39;) &lt;- &#39;America/New_York&#39;; ct; ## [1] &quot;2020-04-28 01:00:00 EDT&quot; attr(ct, which = &#39;tzone&#39;) &lt;- &#39;America/Chicago&#39;; ct ## [1] &quot;2020-04-28 CDT&quot; attr(ct, which = &#39;tzone&#39;) &lt;- &#39;Asia/Tokyo&#39;; ct ## [1] &quot;2020-04-28 14:00:00 JST&quot; # the underlying double type atomic vector unclass(ct)[1] ## [1] 1588050000 Difftimes Difftimes are doubles which represent a duration of time (interpreted by attribute units) between two dates/datetimes. units includes “secs”, “mins”, “hours”, “days”, and “weeks” and are not sensitive to daylight savings time. Limited math methods and arithmetic is available for difftime. See ?difftime. # create difftime directly day &lt;- as.difftime(1, units = &#39;days&#39;) day ## Time difference of 1 days # create difftime by arithmetic day_alt &lt;- as.Date(&quot;2020-04-28&quot;) - as.Date(&quot;2020-04-27&quot;) day_alt ## Time difference of 1 days typeof(day) ## [1] &quot;double&quot; class(day) ## [1] &quot;difftime&quot; attributes(day) ## $class ## [1] &quot;difftime&quot; ## ## $units ## [1] &quot;days&quot; # retrive/set units directly using units() units(day) &lt;- &#39;hours&#39; # day is now a 24 hour timediff day ## Time difference of 24 hours # add difftime to Date to return Date as.Date(&quot;2020-04-28&quot;) + (2*day) ## [1] &quot;2020-04-30&quot; # add difftime to difftime to return difftime as.difftime(.5, units=&#39;mins&#39;) + as.POSIXct(&#39;2020-03-02 00:00:00&#39;) ## [1] &quot;2020-03-02 00:00:30 CST&quot; # transform difftime by numeric to return difftime day/2 ## Time difference of 12 hours # transform difftime by difftime to return difftime day+day ## Time difference of 48 hours # math methods are to describe difftime vectors mean(c(as.Date(&quot;2020-04-28&quot;) - as.Date(&quot;2020-04-27&quot;), as.Date(&quot;2020-04-28&quot;) - as.Date(&quot;2020-04-26&quot;))) ## Time difference of 1.5 days # round difftime etc. round(day, -1) ## Time difference of 20 hours # the underlying double unclass(day)[1] ## [1] 24 Lists Earlier we learned lists are just vectors of references to objects of any type. They have only attribute class “list”. Lists are created with list(). Notice they can contain references to other list, and so are called recursive vectors: l &lt;- list(1, letters[1:10], c(T,T,F,F), list(1)) str(l) ## List of 4 ## $ : num 1 ## $ : chr [1:10] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ : logi [1:4] TRUE TRUE FALSE FALSE ## $ :List of 1 ## ..$ : num 1 c() will convert vectors into lists before combining them: c(list(letters[1:3]), 1:3) %&gt;% str() ## List of 4 ## $ : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## $ : int 1 ## $ : int 2 ## $ : int 3 Testing and coercing lists # test for list type is.list(l) ## [1] TRUE typeof(l) ## [1] &quot;list&quot; # already seen list(), but as.list() exists as well as.list(1:4) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 # to coerce list to vector unlist(l) ## [1] &quot;1&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; ## [9] &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;1&quot; Data frames and tibbles Data frames are the most important data structure for data analysis in R. They are built on top of lists with attributes class “data.frame”, “names” (for columns), and “row.names”; and, crucially, requires each element be a vector of equal length. Tibbles are data frames that were later developed as part of the Tidyverse. They try and optimize the default behavior of class data.frame in the following ways. Creating data.frame or tbl_df data.frame() creates a data frame object from … name = vector pairs: # create character vector and add names attribute &#39;Color&#39; color &lt;- rep(x = c(&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;), times = 2) names(color) &lt;- &#39;Color&#39; df &lt;- data.frame(sock_id = 1:6, # use name = vector pairs color, # or vectors with attribute &quot;names&quot; 6:1, # or let R use defaults `1` = 1 # but non-syntactic names will be renamed without warning ) typeof(df) ## [1] &quot;list&quot; str(df) ## &#39;data.frame&#39;: 6 obs. of 4 variables: ## $ sock_id: int 1 2 3 4 5 6 ## $ color : Factor w/ 3 levels &quot;blue&quot;,&quot;red&quot;,&quot;yellow&quot;: 2 1 3 2 1 3 ## $ X6.1 : int 6 5 4 3 2 1 ## $ X1 : num 1 1 1 1 1 1 Notice data.frame automatically creates factors from character vectors. Inhibit with stringsAsFactors arguement: data.frame(letters[1:3], stringsAsFactors = FALSE) %&gt;% str() ## &#39;data.frame&#39;: 3 obs. of 1 variable: ## $ letters.1.3.: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; Like lists and matrices, data frames and tibbles have row and column names and dimensional length: # column names names(df); colnames(df) ## [1] &quot;sock_id&quot; &quot;color&quot; &quot;X6.1&quot; &quot;X1&quot; ## [1] &quot;sock_id&quot; &quot;color&quot; &quot;X6.1&quot; &quot;X1&quot; # column length length(df); ncol(df) ## [1] 4 ## [1] 4 # row names rownames(df) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; # row length nrow(df) ## [1] 6 # row and column dimensions dim(df) ## [1] 6 4 Tibbles have class “tbl_df” (as well as data.frame) which modifies their behavior. They are created similarly to data frames: library(tibble) tbl &lt;- tibble(sock_id = 1:6, # use name = vector pairs color, # or vectors with attribute &quot;names&quot; 6:1, # or let R use defaults `1` = 1, # allows non-syntactic names `1*2` = `1` * 2 # allows reference to new variables ) typeof(tbl) ## [1] &quot;list&quot; str(tbl) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 6 obs. of 5 variables: ## $ sock_id: int 1 2 3 4 5 6 ## $ color : chr &quot;red&quot; &quot;blue&quot; &quot;yellow&quot; &quot;red&quot; ... ## $ 6:1 : int 6 5 4 3 2 1 ## $ 1 : num 1 1 1 1 1 1 ## $ 1*2 : num 2 2 2 2 2 2 Tibbles can use the same methods as data tables, for example names and dimensional length: colnames(tbl); ncol(tbl) ## [1] &quot;sock_id&quot; &quot;color&quot; &quot;6:1&quot; &quot;1&quot; &quot;1*2&quot; ## [1] 5 rownames(tbl); nrow(tbl) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; ## [1] 6 Notice tibble() did not coerce factors by default, allowed non-syntactic names (enclosed in ````), and let you reference new columns as they are created. Both data frames and tibbles require equal length vector columns and will recycle values if the vector length is smaller than the max column length; however, data frames will recyle any vector that is an integer multiple of the longest column, while tibbles will only recyle scalar values. data.frame(1:4, # the longest column vector of length 4 1, # a scalar recyled 4 times 1:2 # a length 2 vector recyled 2 times ) ## X1.4 X1 X1.2 ## 1 1 1 1 ## 2 2 1 2 ## 3 3 1 1 ## 4 4 1 2 tibble(1:4, # the longest column vector of length 4 1, # a scalar recyled 4 times 1:2 # a length 2 vector recyled 2 times ) ## Error: Tibble columns must have consistent lengths, only values of length one are recycled: ## * Length 2: Column `1:2` ## * Length 4: Column `1:4` Row Names Row names, a unique vector of character, can be assigned to Data frames. This idea probably arose due to data frame’s close association to numerical matrices, where storing character data along with the matrix is useful. Get and set row names with rownames(), or argument row.names on creation: df &lt;- data.frame(idx = 1:3, row.names = c(&#39;Spider Man&#39;,&#39;Batman&#39;,&#39;Red Robin&#39;)) df ## idx ## Spider Man 1 ## Batman 2 ## Red Robin 3 Row names can be used to subset data frames: df[&quot;Batman&quot;,] ## [1] 2 Tibbles do not store row names for reasons you can read here. Rather, they treat rownames as another feature of the data. The rownames argument in as_tibble() or rownames_to_column() can transform row names to a column vector. as_tibble(df, rownames = &quot;Super Hero&quot;) ## # A tibble: 3 x 2 ## `Super Hero` idx ## &lt;chr&gt; &lt;int&gt; ## 1 Spider Man 1 ## 2 Batman 2 ## 3 Red Robin 3 Subsetting Data frames can be subset either one dimensionaly, like a list, or two dimensionally, like a matrix. Data frame subsetting syntax can behave unexpectedly: data.frame()[,vars] will return a data frame unless vars selects only one column; it returns a vector. selecting a single column with data.frame$var will return a column starting with \\$var if $var doesn’t exist. Tibbles always return tibbles, and vectors can be returned when desired with tibble[[var]]. If a column is not found it returns an error. # data frame will select columns starting with cotton when $cotton not found df &lt;- data.frame(cotton_candy = &#39;Yum&#39;) df$cotton ## [1] Yum ## Levels: Yum # tibbles do not match columns starting with cotton as_tibble(df)$cotton ## Warning: Unknown or uninitialised column: &#39;cotton&#39;. ## NULL Testing and coercion Type Testing Coercion data frame is.data.frame() as.data.frame() tibble is.tibble() as.tibble() Note that is.data.frame() will return true for tibbles as well, since tibbles are class data.frame. List Columns Portable Operating System Interface standard.↩ "],
["import.html", "Chapter 1 Import", " Chapter 1 Import "],
["tidy.html", "Chapter 2 Tidy", " Chapter 2 Tidy "],
["transform.html", "Chapter 3 Transform", " Chapter 3 Transform "],
["visualise.html", "Chapter 4 Visualise", " Chapter 4 Visualise "],
["statistics.html", "Chapter 5 Statistics", " Chapter 5 Statistics "],
["communicate.html", "Chapter 6 Communicate", " Chapter 6 Communicate "],
["markdownbookdown-tips.html", "6.1 Markdown/bookdown tips", " 6.1 Markdown/bookdown tips 6.1.1 Syntax Inline Formatting Element Code Notes Italic *Italic* or _Italic_ single asterisks or underscores Bold **Bold** or __Bold__ double asterisks or underscores Bold Italic ***Bold Italic*** triple asterisks or underscores Underline __Underline__ two underscores Strike-through ~~Strike-through~~ double tildes Subscript Sub~script~ single tildes Superscript Super^script^ single carets \\(\\LaTeX\\) $\\LaTeX$ enclose syntax with $ inline_code() `inline_code()` single back-ticks R, Inline, Code `r c('R','Inline','Code')` single back-ticks beginning r space Hyperlink [Hyperlink](https://www.google.com) [text](link) ![R Logo](./Rlogo.png) ![text](link) Footnote2 ^[Example footnote.] requires a . Citation (2020) @example @tag ref to BibTeX citation (Citation 2020) [@example] alternative style Section Headers # level 1 header ## level 2 header ### level 3 header etc... Add {-} after the header to remove section numbering: # Preface {-} Unordered Lists item 1 item 2 sub-item 1 Unordered list items start with *, -, or +; and can be nested by indenting the next item by four spaces: * item 1 * item 2 * sub-item 1 Ordered lists item 1 item 2 sub-item 1 Ordered lists begin with a number and a period. Same indenting rules as unordered lists: 1. item 1 2. item 2 1. sub-item 1 Block Quotes \"You miss 100% of the shots you don’t take. — Wayne Gretzky\" — Michael Scott Block quotes begin with a &gt;. You can use markdown formatting or HTML tags to right align the author: &gt; &quot;You miss 100% of the shots you don&#39;t take. &gt; &gt; --- Wayne Gretzky&quot; &gt; &gt; &lt;div style=&quot;text-align: right&quot;&gt; --- Michael Scott&lt;/div&gt; Code Blocks ``` Use three back ticks to display text without markdown formatting. ``` 6.1.1.1 Tables 6.1.1.1.1 Grid Tables Basic tables can be used by aligning +,-, &amp; | in a grid as below. One advantage is the ability to put more than one markdown element in a cell. No alignment options are available and you may have to reformat your table manually. +------------+--------+--------+ |Date |Event | Times| +------------+--------+--------+ |30-Apr-2020 |Swimming|* 3:00pm| | | |* 4:30pm| +------------+--------+--------+ Date Event Times 30-Apr-2020 Swimming 3:00pm 4:30pm 6.1.1.1.2 Pipe Tables Horizontal Rules Three or more ***, ---, or ___ will produce a horizontal rule; as will the &lt;hr&gt; HTML tag. 6.1.2 Cache large code chunks ```{r chunk-id, cache=TRUE} 6.1.3 Chunk Options 6.1.3.1 Collapse collapse=TRUE results in x &lt;- 1:10; print(x) ## [1] 1 2 3 4 5 6 7 8 9 10 rather than x &lt;- 1:10; print(x) ## [1] 1 2 3 4 5 6 7 8 9 10 6.1.3.2 Error error=TRUE Resources Bookdown: Authoring Books with R Markdown by its creator, Yihui Xie. Pandoc Chapter Session Info ## R version 3.6.1 (2019-07-05) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18363) ## ## Matrix products: default ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_3.6.1 magrittr_1.5 bookdown_0.16 tools_3.6.1 ## [5] htmltools_0.4.0 yaml_2.2.0 Rcpp_1.0.1 stringi_1.4.3 ## [9] rmarkdown_1.13 knitr_1.23 stringr_1.4.0 xfun_0.8 ## [13] digest_0.6.20 rlang_0.4.5 evaluate_0.14 "]
]
